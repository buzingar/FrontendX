# 前端基础

## javascript

### [原型链](https://github.com/mqyqingfeng/Blog/issues/2)

构造函数都有 prototype 属性，指向一个实例，
实例都有\_\_proto\_\_属性，new 的时候添加，
将实例的隐式属性\_\_proto\_\_指向构造函数的 prototype，
而构造函数的 prototype 也是一个实例，这样递进式引用，就形成了一条实例链即原型链

### [继承](https://github.com/mqyqingfeng/Blog/issues/16)

#### ES5 继承

> Douglas Crockford

原型链继承

`Child.prototype = new Parent();`

缺点：缺少构造函数，不能传递参数；继承原型链，未获得构造函数中的属性和方法；引用共享；

借用构造函数继承

`Parent.call(Child, args)`

缺点：没有用到原型链，无法复用原型链上的方法和属性，只能继承父类的实例属性和方法

组合式继承

将原型链和构造函数组合起来使用，既能参数传递，也解决了原型链复用问题，也不存在参数共享的问题了；
使用原型链实现对原型属性和方法的继承，而通过构造函数实现对实例属性的继承；

缺点：Parent 构造函数两次被调用，性能损耗

原型式继承

该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用 new 操作符创建实例，并返回这个实例

寄生式继承

寄生组合式继承

为了解决组合式继承两次调用构造函数的缺点，优化掉原型链继承的那次 new Parent 动作。

做法：以 Parent 为模板，创建一个新的中间态构造函数 F()，将 F 的 prototype 指向 Parent 的 prototype，new F() 后得到简化版实例并返回，作为 Child.prototype 的指向点，并修改此实例的 constructor 属性指向 Child。

#### ES6 继承

class extends

### [作用域](https://github.com/mqyqingfeng/Blog/issues/6)

代码执行的上下文环境，包括变量对象 VO，作用域链 scope chain，this

引申

作用域链，即作用域内变量查找的一个导向链，从当前作用域开始查找，找到即停止，找不到就会去包裹当前作用域的更大的作用域内查找，如此递进式查找，直到根作用域，浏览器环境就是 window 所在的全局作用域。

内部属性 [[scope]]

在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。

未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。

调用函数时，会为其创建一个 Arguments 对象，并自动初始化局部变量 arguments，指代该 Arguments 对象。所有作为参数传入的值都会成为 Arguments 对象的数组元素。

一个执行上下文的生命周期可以分为两个阶段:

- 创建阶段

  在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定 this 的指向。

- 代码执行阶段

  创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。

### [闭包](https://github.com/mqyqingfeng/Blog/issues/9)

以下函数才算是闭包：

- 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
- 在代码中引用了自由变量

通俗的说就是，函数 A 内返回另一个函数 B，函数 B 仍能保持对函数 A 的变量的引用，而函数执行完就会弹出执行上下文栈，也就会被销毁，函数 A 的变量就是自由变量。

> 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。

作用

- 实现私有变量
- 保护命名空间，避免污染全局变量
- 使变量留存在内存中不随函数调用而消亡

缺点

<b>可能引起内存泄漏</b>

引申

函数的生命周期

### [变量提升](https://github.com/mqyqingfeng/Blog/issues/5)

非严格模式下 var function 才会有，变量或函数在实际代码中并不是在作用域顶端声明的，但运行时 js 引擎将变量的声明提升到了作用域顶端，这样使得即使在其声明之前也能使用这些变量而不会报错。

同一作用域下，函数提升比变量提升得更靠前。

let const 不存在变量提升，就会形成暂时性死区，TDZ

- 所有的声明都会提升到作用域的顶部。
- 函数声明的优先级高于变量声明的优先级，并且函数声明和函数定义的部分一起被提升。
- 同一个变量只会声明一次，其他的会被忽略掉或者覆盖掉。

```javascript
'use strict';
console.log(v1);
var v1 = 100; // 变量提升（声明提升，赋值未提升）
function foo() {
  console.log(v1);
  var v1 = 200; // 变量提升（声明提升，赋值未提升）
  console.log(v1);
}
foo();
console.log(v1);

/* -------------------------------------- */
bar();
var bar = function () {
  console.log(1);
};
// 报错：TypeError: bar is not a function
/* -------------------------------------- */
bar();
function bar() {
  console.log(1);
}
// 输出结果1
/* -------------------------------------- */
```

#### 严格模式的限制

1. 不允许使用未声明的变量
2. 不允许删除变量或对象
3. 不允许删除函数
4. 不允许变量重名
5. 不允许使用八进制
6. 不允许使用转义字符
7. 不允许对只读属性赋值
8. 不允许对使用 getter 方法读取的属性进行赋值
9. 不允许删除一个不允许删除的属性
10. 变量名不能使用“eval”、“arguments”字符串
11. 由于一些安全原因，在作用域 eval() 创建的变量不能被调用
12. 禁止 this 关键字指向全局对象

### [this 的指向](https://github.com/mqyqingfeng/Blog/issues/7)

this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 的最终指向的是那个调用它的对象。

函数是被谁点出来的

如果函数引用被赋值给别的变量，记得只是多了个指向函数的引用罢了，相当于函数表达式一样。对函数的调用不会再经过原来的调用路线。

### [立即执行](https://segmentfault.com/a/1190000003985390)

立即执行函数表达式 IIFE immediately-invoked-function-expression

在 JavaScript 里，每个函数，当被调用时，都会创建一个新的执行上下文。这个上下文提供了一个非常简单的方法创建私有变量。确保在函数里定义的变量和函数是只能在函数内部被访问到。

function expressions and function declarations
函数表达式与函数声明

```javascript
/* (function () {}()); */ //Crockford recommends this one，括号内的表达式代表函数立即调用表达式
(function () {
  /* code */
})(); //But this one works just as well，括号内的表达式代表函数表达式
```

为什么需要 IIFE？

如果只是为了立即执行一个函数，显然 IIFE 所带来的好处有限。

`实际上，IIFE 的出现是为了弥补 JS 在 scope 方面的缺陷`：JS 只有全局作用域（global scope）、函数作用域（function scope），从 ES6 开始才有块级作用域（block scope）。

对比现在流行的其他面向对象的语言可以看出，JS 在访问控制这方面是多么的脆弱！那么`如何实现作用域的隔离呢`？在 JS 中，`只有 function 才能实现作用域隔离`，因此如果要将一段代码中的变量、函数等的定义隔离出来，只能将这段代码封装到一个函数中。

在我们通常的理解中，将代码封装到函数中的目的是为了复用。在 JS 中，当然声明函数的目的在大多数情况下也是为了复用，但是 JS 迫于`作用域控制手段的贫乏`，我们也经常看到`只使用一次的函数：这通常的目的是为了隔离作用域`了！既然只使用一次，那么立即执行好了！既然只使用一次，函数的名字也可以省掉了！这就是 IIFE 的由来。

IIFE 的用处

- 利用函数的执行来创造私有变量，作用域的隔离，避免污染全局变量
- IIFE 构造单例模式

### [instanceof 原理](https://juejin.cn/post/6844903613584654344)

就是 递进式判断 实例的隐式\_\_proto\_\_ 是否严格等于 构造函数的 prototype

```javascript
function isInstanceof(inst, Ctor) {
  var i = inst.__proto__;
  var p = Ctor.prototype;

  while (true) {
    if (i == null) {
      return;
    }
    if (i === p) {
      return true;
    }
    i = i.__proto__;
  }
}

function Student(name, age) {
  this.name = name;
  this.age = age;
}
const student = new Student('gornin', 18);
isInstanceof(student, Student);
// console.log(student instanceof Student);
```

### [柯里化](https://github.com/mqyqingfeng/Blog/issues/42)

柯里化：半执行函数，具有参数记忆功能，利用闭包，返回一个新函数

```javascript
const add = (a) => (b) => (c) => a + b + c;
add(1)(2)(3);

// es5
var add = function add(a) {
  return function (b) {
    return function (c) {
      return a + b + c;
    };
  };
};

// 自己实现
function createAdd(fn) {
  var params = [];
  var len = fn.length;

  return function add() {
    var curlen = arguments.length;
    params = params.concat([].slice.call(arguments));
    len = len - curlen;
    return len > 0 ? add : fn.apply(null, params);
  };
}

var add = createAdd(function (a, b, c) {
  return a + b + c;
});

add(1)(2)(3);
```

### [bind 实现](https://github.com/mqyqingfeng/Blog/issues/12)

```javascript
Function.prototype.ibind = function (context) {
  let that = this;
  let bindArgs = Array.prototype.slice.apply(arguments, [1]); // [].slice()

  function createInst() {
    // 中间函数，寄生式
    function Fn() {}
    // 继承原型上的属性和方法，this指向老函数
    Fn.prototype = that.prototype;
    return new Fn();
  }

  function newFunc() {
    let args = Array.prototype.slice.apply(arguments, [0]);
    let totalArgs = bindArgs.concat(args);

    return that.apply(
      this instanceof newFunc ? this /* test */ : context,
      totalArgs
    );
  }

  // 相当于new this()得到的实例
  newFunc.prototype = createInst();

  return newFunc;
};

const test = function (a, b) {
  console.log('作用域绑定 ' + this.value); // obj.value -> ok
  console.log('ibind参数传递 ' + a.value2); // ibind入参 -> also ok
  console.log('调用参数传递 ' + b); // 新函数调用入参 -> hello bind
};
const obj = {
  value: 'ok',
};
const newfunc = test.ibind(obj, { value2: 'also ok' }); // obj.test()

newfunc('hello bind');
```

### [apply 与 call](https://segmentfault.com/a/1190000018017796)

```javascript
// context 即 foo，函数调用者，this的源头
// args 调用函数icall的函数即getName的入参
Function.prototype.icall = function (context, ...args) {
  // 将传入的对象保存起来，即foo对象
  let thisArg = context || window;
  // console.log(thisArg);

  // 此函数中的this指向的是icall方法的调用者 即getName方法，也就是我们需要借用的方法
  // 因此我们直接将this赋值给传入对象的临时属性borrowedFunc
  thisArg.borrowedFunc = this; // foo.borrowedFunc = getName
  // console.log(this);

  // 执行thisArg.borrowedFunc方法即是执行getName方法，得到运算结果
  // 如果这里直接写成 this(...args); getName里的this指向将有问题
  let result = thisArg.borrowedFunc(...args); // foo.getName(...args)

  // 删除传入对象的临时属性
  delete thisArg.borrowedFunc;

  // 返回调用执行的结果
  return result;
};

function getName(words) {
  const name = 'origin';
  console.log('send:', words);
  console.log(this);
  return this.name;
}

const foo = {
  name: 'gornin',
};

getName.icall(foo, 'hello');
```

### [new 操作符](https://github.com/mqyqingfeng/Blog/issues/13)

- 创建一个空对象，构造函数中的 this 指向这个空对象
- 这个新对象被执行 [[原型]] 连接
- 执行构造函数方法，属性和方法被添加到 this 引用的对象中
- 如果构造函数中没有返回其它对象，那么返回 this，即创建的这个的新对象，否则，返回构造函数中返回的对象。

```javascript
function _new() {
  // 第一个参数是构造函数
  let [ctor, ...args] = [...arguments];
  // 空对象
  let target = {};
  // shift()用于把数组的第一个元素从其中删除,并返回第一个元素的值,取出参数列表的第一个参数（构造函数）
  // 也可以 let constructor = [].shift.call(arguments);
  // console.log('ctor:', constructor);
  // [[proto]]连接,手动指正target的构造函数为constructor（链接原型）
  target.__proto__ = ctor.prototype;
  // 执行构造函数，将属性和方法添加到创建的空对象上
  // 调用constructor，改变this为target，传入剩余参数arguments
  // 此时构造函数中的this为target，即target.name = name; target.age = age;
  let result = ctor.apply(target, args);
  // console.log('result:', result);
  // 如果构造函数执行的结构返回的是一个对象，则返回此对象
  if (result && (typeof result == 'object' || typeof result == 'function')) {
    return result;
  }
  // 如果构造函数返回的不是一个对象，返回创建的新对象
  return target;
}
```

### [事件循环机制](https://zhuanlan.zhihu.com/p/33058983)

javascript 从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。

单线程意味着，javascript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。

而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 I/O 事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。

#### 为什么 js 要设计成单线程？

单线程是必要的，也是 javascript 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 dom 操作。试想一下，如果 javascript 是多线程的，那么当两个线程同时对 dom 进行一项操作，例如一个向其添加事件，而另一个删除了这个 dom，此时该如何处理呢？因此，为了保证不会发生类似于这个例子中的情景，javascript 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。

#### 执行栈

当 javascript 代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些`对象`。而栈中则存放着一些`基础类型变量以及对象的指针`。

当我们调用一个方法的时候，js 会生成一个`与这个方法对应的执行环境（context），又叫执行上下文 EC`。这个执行环境中存在着这个方法的`私有作用域`、`上层作用域的指向`、`方法的参数`、`这个作用域中定义的变量`以及`这个作用域的 this 对象`。当一系列方法被依次调用的时候，因为 js 是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为`执行栈`，栈 FILO，先进后出。

当一个脚本第一次执行的时候，js 引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么 `js 会向执行栈中添加这个方法的执行环境EC`，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码执行完毕并返回结果后，js 会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。

#### 事件队列

当一个异步代码（如发送 ajax 请求数据）执行后会如何呢？js 的另一大特点是非阻塞，实现这一点的关键在于事件队列（Task Queue）机制。

js 引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。

当一个异步事件返回结果后，js 会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列后不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，主线程才会`去查找事件队列是否有任务(下一段区分更细致)`。如果有，那么主线程会从中取出排在第一位的事件，并`把这个事件对应的回调放入执行栈中`，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这个过程被称为“事件循环（Event Loop）”。

在一个事件循环中，异步事件返回结果后会被放到一个事件队列中。然而，根据这个异步事件的类型(异步任务并不相同)，他们的执行优先级也有区别，异步任务被分为两类：微任务（micro task）和宏任务（macro task），这个事件实际上会被分配到对应的宏任务队列或者微任务队列中去。在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出最前面的一个事件并把对应的回调加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。

> 首先我们要明白，事件循环机制是用来处理异步事件的，同步事件按顺序执行，执行完就有结果，不需要事件队列介入；
>
> 异步事件不会当即得到结果，js 非阻塞，会将异步事件挂起，等到事件有了结果，js 将此事件加入事件队列中进行排队，等待主线程处理完执行栈中任务后，空闲时处理事件队列中的事件。
>
> 事件队列又分为宏任务队列和微任务队列，微任务队列包含的是当前宏任务的微任务，优先级更高一点，会先被处理，宏任务队列中事件只能等当前宏任务执行完毕才会被处理。
>
> 处理方式：将事件对应的回调函数加入执行栈，执行此函数。至此为一趴。
>
> 执行栈不断有同步事件的 EC 入栈出栈，事件队列不断有异步事件入队出队，如此往复循环，是为事件循环

node.js 的事件循环 与浏览器环境有何不同?
在 node 中，事件循环表现出的状态与浏览器中大致相同。不同的是 node 中有一套自己的模型。node 中事件循环的实现是依靠的 libuv 引擎。我们知道 node 选择 chrome v8 引擎作为 js 解释器，v8 引擎将 js 代码分析后去调用对应的 node api，而这些 api 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 node 中的事件循环存在于 libuv 引擎中。

libuv 引擎中的事件循环的模型：
timers -> I/O callbacks -> idle,prepare -> poll -> check -> close callbacks -> timers

- `timers`: 这个阶段`以先进先出的方式`执行`定时器队列`(存放所有到期的 timer)中的回调 callback，如 setTimeout() 和 setInterval()
- `I/O callbacks`: 这个阶段执行几乎所有的回调，主要执行大部分 I/O 事件的回调，包括一些为操作系统执行的回调。但是不包括 close 事件，定时器和 setImmediate()的回调。
- `idle, prepare`: 这个阶段仅在内部使用，可以不必理会。
- `poll`: 当 v8 引擎将 js 代码解析后传入 libuv 引擎后，循环首先进入 poll 阶段。此阶段等待新的 I/O 事件，node 在一些特殊情况下会阻塞在这里。
- `check`: 此阶段专门用来执行 setImmediate() 的回调。当 poll 阶段进入空闲状态，并且 `setImmediate queue` 中有 callback 时进入此阶段。
- `close callbacks`: 例如 socket.on('close', ...)这种 close 事件的回调

外部输入数据 incoming-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timers)-->I/O 事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段...

poll 阶段的执行逻辑：

1. 先 `查看 poll queue` 中是否有事件，有任务就按先进先出的顺序依次执行回调。
2. 当 queue 为空时，会检查`setImmediate queue`是否有 setImmediate()的 callback，如果有就进入 check 阶段执行这些 callback。
3. 但同时也会`检查是否有到期的 timer`，如果有，就把这些到期的 timer 的 callback 按照调用顺序放到 timer queue 中，之后循环会进入 timer 阶段执行 queue 中的 callback。 这两者的顺序是不固定的，受到代码运行环境的影响。
4. 如果两者的 queue 都是空的，那么 loop 会在 poll 阶段停留，直到有一个 i/o 事件返回。
5. 循环会进入 i/o callback 阶段并立即执行这个事件的 callback。

值得注意的是，poll 阶段在执行 poll queue 中的回调时实际上不会无限的执行下去。有两种情况 poll 阶段会终止执行 poll queue 中的下一个回调：1.所有回调执行完毕。2.执行数超过了 node 的限制。

#### process.nextTick,setTimeout（setInterval 与之相同）与 setImmediate

process.nextTick：当事件循环准备进入下一个阶段之前，会先检查 nextTick queue 中是否有任务，如果有，那么会先清空这个队列。

在 I/O 事件的回调中，setImmediate 方法的回调永远在 timer 的回调前执行。

### [promise 原理](https://juejin.cn/post/6844904063570542599)

```javascript
function Promise(fn) {
  // 记录状态
  let state = 'pending';
  // 状态改变时的值信息
  let value = null;
  // 存放异步回调
  const callbacks = [];

  this.then = function (onFulfilled, onRejected) {
    return new Promise((resolve, reject) => {
      handle({
        onFulfilled,
        onRejected,
        resolve,
        reject,
      });
    });
  };

  // 捕获异常，执行onRejected的逻辑
  this.catch = function (onError) {
    return this.then(null, onError);
  };

  // 终点逻辑
  this.finally = function (onDone) {
    this.then(onDone, onError);
  };

  this.resolve = function (value) {
    if (value && value instanceof Promise) {
      return value;
    }
    if (
      value &&
      typeof value === 'object' &&
      typeof value.then === 'function'
    ) {
      const { then } = value;
      return new Promise((resolve) => {
        then(resolve);
      });
    }
    if (value) {
      return new Promise((resolve) => resolve(value));
    }
    return new Promise((resolve) => resolve());
  };

  this.reject = function (value) {
    return new Promise((resolve, reject) => {
      reject(value);
    });
  };

  // all，接收promise实例数组，将所有promise的返回结果合并后用一个promise返回
  this.all = function (arr) {
    const args = Array.prototype.slice.call(arr);
    return new Promise((resolve, reject) => {
      if (args.length === 0) return resolve([]);
      let remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            const { then } = val;
            if (typeof then === 'function') {
              then.call(
                val,
                (val) => {
                  res(i, val);
                },
                reject
              );
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }
      for (let i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  this.race = function (values) {
    return new Promise((resolve, reject) => {
      for (let i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // 根据调用情况看 callback = {onFulfilled,onRejected,resolve,reject} || fn
  function handle(callback) {
    if (state === 'pending') {
      callbacks.push(callback);
      return;
    }

    // 进入then，且状态改变
    const cb =
      state === 'fulfilled' ? callback.onFulfilled : callback.onRejected;
    const next = state === 'fulfilled' ? callback.resolve : callback.reject;

    // TODO cb不存在或falsy状态?
    if (!cb) {
      next(value); // callback.reject(value)
      return;
    }
    let ret;
    try {
      ret = cb(value);
    } catch (e) {
      callback.reject(e);
    }
    callback.resolve(ret);
  }

  function resolve(newValue) {
    const fn = () => {
      if (state !== 'pending') return;

      // newValue为一个promise
      if (
        newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')
      ) {
        const { then } = newValue;
        if (typeof then === 'function') {
          // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve
          // 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调
          then.call(newValue, resolve, reject);
          return;
        }
      }
      state = 'fulfilled';
      value = newValue;
      // 发布者发布
      handelCb();
    };

    setTimeout(fn, 0);
  }

  function reject(error) {
    const fn = () => {
      if (state !== 'pending') return;
      // error为一个promise
      if (error && (typeof error === 'object' || typeof error === 'function')) {
        const { then } = error;
        if (typeof then === 'function') {
          then.call(error, resolve, reject);
          return;
        }
      }
      state = 'rejected';
      value = error;
      // 发布者发布
      handelCb();
    };
    setTimeout(fn, 0);
  }

  function handelCb() {
    // 当队列不为空，一直执行知道为空
    while (callbacks.length) {
      // 取头一个，FIFO
      const fn = callbacks.shift();
      // 执行回调
      handle(fn);
    }
  }

  try {
    // new Promise((resovle, reject)=>{})，此处先执行，入有错执行reject
    fn(resolve, reject);
  } catch (ex) {
    reject(ex);
  }
}
```

### [generator 原理](http://www.alloyteam.com/2016/02/generators-in-depth/)

Generators 允许我们在函数执行过程中暂停、并在将来某一时刻恢复执行。这一特性改变了以往函数必须执行完成才返回的特点，将这一特性应用到异步代码编写中，可以有效的简化异步方法的写法，同时避免陷入回调地狱。

#### 示例

```javascript
function* example() {
  yield 1;
  yield 2;
  yield 3;
}
// 返回一个生成器对象
var iter = example();
iter.next(); //{value:1，done:false}
iter.next(); //{value:2，done:false}
iter.next(); //{value:3，done:false}
iter.next(); //{value:undefined，done:true}
```

调用生成器函数，返回一个生成器对象，每当调用生成器对象的.next() 方法时，函数将运行到下一个 yield 表达式，返回表达式结果并暂停自身。当抵达生成器函数的末尾时，返回结果中 done 的值为 true，value 的值为 undefined。

#### 生成器函数，与普通函数相比二者有如下区别

- 普通函数使用 function 声明，生成器函数用 function\*声明
- 普通函数使用 return 返回值，生成器函数使用 yield 返回值
- 普通函数是 `run to completion` 模式，即普通函数开始执行后，会一直执行到该函数所有语句完成，在此期间别的代码语句是不会被执行的；生成器函数是 `run-pause-run` 模式，即生成器函数可以在函数运行中被暂停一次或多次，并且在后面再恢复执行，在暂停期间允许其他代码语句被执行。

#### yield 关键字在 Javascript 中如何实现呢？

首先，生成器不是线程。支持线程的语言中，多段不同的代码可以在同一时候运行，这经常会导致资源竞争，使用得当会有不错的性能提升。生成器则完全不同，Javascript 执行引擎仍然是一个基于事件循环的单线程环境，当生成器运行的时候，它会在叫做 caller 的同一个线程中运行。执行的顺序是有序、确定的，并且永远不会产生并发。不同于系统的线程，生成器只会在其内部用到 yield 的时候才会被挂起。

既然生成器并非由引擎从底层提供额外的支持，我们可以将生成器视为一个语法糖，用一个辅助工具将生成器函数转换为普通的 Javascript 代码，在经过转换的代码中，有两个关键点，`一是要保存函数的上下文信息`，`二是实现一个完善的迭代方法，使得多个 yield 表达式按序执行`，从而实现生成器的特性。

#### 状态机模型(四种状态)

- Before 为迭代器初始状态，`MoveNext` 离开此状态
- Running 为调用 `MoveNext` 后进入此状态。在这个状态，枚举数检测并设置下一项的位置。遇到 `yield return`、`yield break` 或者`迭代结束`时，退出该状态
- Suspended 为状态机等待下次调用 MoveNext 的状态，`yield return` 进入此状态
- After 为迭代结束的状态，`yield break` 或者`迭代结束`时进入此状态

#### 先总结，生成器的运行原理

Regenerator 通过工具函数将生成器函数包装，为其添加如 next/return 等方法。同时也对返回的生成器对象进行包装，使得对 next 等方法的调用，最终进入由 switch case 组成的`状态机模型`中。除此之外，利用`闭包技巧`，保存生成器函数上下文信息。

```javascript
/*
function* example() {
  yield 1;
  yield 2;
  yield 3;
}
*/
// 经babel转化后，http://babeljs.io/repl/
// 迭代器函数 example 被 regeneratorRuntime.mark 包装，返回一个被 regeneratorRuntime.wrap 包装的迭代器对象
var _marked = /*#__PURE__*/ regeneratorRuntime.mark(example);

function example() {
  // 迭代器对象
  return regeneratorRuntime.wrap(function example$(_context) {
    while (1) {
      // yield 表达式重写为 switch case
      switch ((_context.prev = _context.next)) {
        case 0:
          // _context 保存函数当前的上下文状态
          _context.next = 2;
          return 1;

        case 2:
          _context.next = 4;
          return 2;

        case 4:
          _context.next = 6;
          return 3;

        case 6:
        case 'end':
          return _context.stop();
      }
    }
  }, _marked);
}

var iter = example();
iter.next();
```

runtime.wrap & mark

```javascript
runtime.mark = function (genFun) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
  } else {
    genFun.__proto__ = GeneratorFunctionPrototype;
  }
  genFun.prototype = Object.create(Gp);
  return genFun;
};

runtime.wrap = function (innerFn, outerFn, self, tryLocsList) {
  // If outerFn provided, then outerFn.prototype instanceof Generator.
  var generator = Object.create((outerFn || Generator).prototype);
  var context = new Context(tryLocsList || []);

  // The ._invoke method unifies the implementations of the .next,
  // .throw, and .return methods.
  generator._invoke = makeInvokeMethod(innerFn, self, context);

  return generator;
};
```

1. runtime.mark()
2. runtime.wrap()
3. defineIteratorMethods 方法会添加"next", "throw", "return"
4. 当调用迭代器对象 iter.next() 方法时，会执行\_invoke 方法，即 makeInvokeMethod (innerFn, self, context)
5. makeInvokeMethod 返回 invoke 函数，调用 invoke 实际调用 tryCatch
6. tryCatch 方法中 fn 为经过转换后的 example$ 方法，arg 为上下文对象 context, 因为 invoke 函数内部对 context 的引用形成闭包引用，所以 context 上下文得以在迭代期间一直保持。
7. tryCatch 方法会实际调用 example$ 方法，进入转换后的 switch case, 执行代码逻辑

### [v8 垃圾回收机制](https://juejin.cn/post/6844904016325902344)

垃圾回收用来减少内存占比，提高性能

> 如果在这个作用域被销毁的过程中，其中的变量不被回收，即持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕之后理当归还给操作系统以保证内存的重复利用。

#### V8 引擎的内存限制

- JS 是单线程的，那么也就意味着在 V8 执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段，直到垃圾回收结束后才会再次重新执行 JS 逻辑。因此，由于 JS 的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。

- 如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，浏览器也就越长时间得不到响应。

基于以上两点，V8 引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小。

#### 垃圾回收策略

V8 的垃圾回收策略主要是基于`分代式垃圾回收机制`，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。即，`以存活时间分代，不同分代，采用不同算法`。

#### v8 内存结构

- `新生代(new_space)`——大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，一半内存，一半需保留对象
- `老生代(old_space)`——新生代中的对象在存活一段时间后就会被转移到老生代内存区，又分为`老生代指针区`和`老生代数据区`
- `大对象区(large_object_space)`——存放体积超越其他区域大小的对象
- `代码区(code_space)`——唯一拥有执行权限的内存区域
- `map 区(map_space)`——存放 Cell 和 Map

在新生代的垃圾回收过程中主要采用了 Scavenge 算法，一种典型的牺牲空间换取时间的算法。

从新生代转移到老生代的过程我们称之为晋升。对象晋升的条件主要有以下两个：

- From 空间对象是否经历过一次 Scavenge 算法，是，晋升，否，去 To 空间
- To 空间的内存占比是否已经超过 25%，是，From 空间对象会直接晋升

在老生代中，管理着大量的存活对象，采用新的算法 Mark-Sweep(标记清除)和 Mark-Compact(标记整理)来进行管理。

- 为了避免循环引用导致的内存泄漏问题，放弃了引用计数算法。
- Mark-Sweep(标记清除)的问题，所清理的对象的内存地址可能不是连续的，就会出现内存碎片的问题，有可能(非必要的)提前触发垃圾回收。
- Mark-Compact(标记整理)，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存，可解决内存的碎片化问题

#### 全停顿(stop-the-world)

由于 JS 的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑。一般来说，老生代会保存大量存活的对象，如果在标记阶段将整个堆内存遍历一遍，那么势必会造成严重的卡顿。

为了减少垃圾回收带来的停顿时间，V8 引擎又引入了 Incremental Marking(增量标记)的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给 JS 主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。`似曾相识，React Fiber 也是这个思路，可以中断执行之后再恢复继续执行`。

v8 让清理和整理的过程也变成增量式的，引入 `延迟清理(lazy sweeping)`和`增量式整理(incremental compaction)`，为了充分利用多核 CPU 的性能，也将引入`并行标记`和`并行清理`。

目的：`尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能`。

#### 如何避免内存泄漏

- 尽可能少地创建全局变量

  在 window 上挂载的属性均可以被访问到，并将其标记为活动的从而常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁。非必须使用，使用完毕后记得将其设置为 null。

- 手动清除定时器

  由于我们没有手动清除定时器，有可能导致回调任务会不断地执行下去，有可能导致内存泄漏

- 少用闭包

  一般情况下，当 外层函数执行完毕后，它的作用域会被销毁，但由于存在外层函数以外的变量引用其返回的函数，导致作用域无法得到释放，也就导致外层函数变量无法回收，只有当我们取消掉对被返回函数的引用才会进入垃圾回收阶段。

- 清除 DOM 引用

  而不仅仅是移除元素 removeChild 那么简单，需要清除掉引用

- 弱引用

  在 ES6 中为我们新增了两个有效的数据结构 WeakMap 和 WeakSet，就是为了解决内存泄漏的问题而诞生的。其表示弱引用，它的键名所引用的对象均是弱引用，`弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去`，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。

#### 弱引用

```javascript
// node --expose-gc // --expose-gc 表示允许手动执行垃圾回收机制
// 手动执行一次垃圾回收保证内存数据准确
> global.gc();
undefined

// 查看当前占用的内存，主要关心heapUsed字段，大小约为4.4MB
> process.memoryUsage();
{ rss: 21626880,
  heapTotal: 7585792,
  heapUsed: 4708440,
  external: 8710 }

// 创建一个WeakMap
> let wm = new WeakMap();
undefined

// 创建一个数组并赋值给变量key
> let key = new Array(1000000);
undefined

// 将WeakMap的键名指向该数组
// 此时该数组存在两个引用，一个是key，一个是WeakMap的键名
// 注意WeakMap是弱引用
> wm.set(key, 1);
WeakMap { [items unknown] }

// 手动执行一次垃圾回收
> global.gc();
undefined

// 再次查看内存占用大小，heapUsed已经增加到约12MB
> process.memoryUsage();
{ rss: 30232576,
  heapTotal: 17694720,
  heapUsed: 13068464,
  external: 8688 }

// 手动清除变量key对数组的引用
// 注意这里并没有清除WeakMap中键名对数组的引用
> key = null;
null

// 再次执行垃圾回收
> global.gc()
undefined

// 查看内存占用大小，发现heapUsed已经回到了之前的大小(这里约为4.8M，原来为4.4M，稍微有些浮动)
> process.memoryUsage();
{ rss: 22110208,
  heapTotal: 9158656,
  heapUsed: 5089752,
  external: 8698 }

```

### [浮点数精度](https://github.com/mqyqingfeng/Blog/issues/155)

> 类似问题 https://www.cnblogs.com/zhangycun/p/7880580.html

ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。

在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32 位）、双精确度（64 位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。

#### 浮点数转二进制

我们来看下 1020 用十进制的表示：

`1020 = 1 \* 10^3 + 0 \* 10^2 + 2 \* 10^1 + 0 \* 10^0`

所以 1020 用十进制表示就是 1020……(哈哈)

如果 1020 用二进制来表示呢？

`1020 = 1 \* 2^9 + 1 \* 2^8 + 1 \* 2^7 + 1 \* 2^6 + 1 \* 2^5 + 1 \* 2^4 + 1 \* 2^3 + 1 \* 2^2 + 0 \* 2^1 + 0 \* 2^0`

所以 1020 的二进制为 1111111100

那如果是 0.75 用二进制表示呢？同理应该是：

`0.75 = a \* 2^-1 + b \* 2^-2 + c \* 2^-3 + d \* 2^-4 + ...`

因为使用的是二进制，这里的 abcd……的值的要么是 0 要么是 1。

那怎么算出 abcd…… 的值呢，我们可以两边不停的乘以 2 算出来，解法如下：

`0.75 = a \* 2^-1 + b \* 2^-2 + c \* 2^-3 + d \* 2^-4 + ...`

两边同时乘以 2

`1 + 0.5 = a \* 2^0 + b \* 2^-1 + c \* 2^-2 + d \* 2^-3... (所以 a = 1)`

剩下的：

`0.5 = b \* 2^-1 + c \* 2^-2 + d \* 2^-3...`

再同时乘以 2

`1 + 0 = b \* 2^0 + c \* 2^-2 + d \* 2^-3... (所以 b = 1)`

所以 0.75 用二进制表示就是 0.ab，也就是 0.11

0.1 用二进制表示就是 0.00011001100110011……，这个计算在不停的循环

`0.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...`

#### 浮点数的存储

IEEE754 这个标准认为，一个浮点数 (Value) 可以这样表示：

`Value = sign * exponent * fraction`

-1020 -> `-1 * 10^3 * 1.02` -> sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02

`V = (-1)^S * (1 + Fraction) * 2^E`

我们会用 1 位存储 S，0 表示正数，1 表示负数。

用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。

用 52 位存储 Fraction。

> 就拿 0.1 来看，对应二进制是 1 \* 1.1001100110011…… \* 2^-4， Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011……

所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。0.2 亦是。

#### 浮点数的运算

关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算。

1. 对阶，就是把阶码调整为相同，调整原则是小阶对大阶
2. 尾数计算
3. 结果规格化
4. 舍入，超出范围要被舍弃，四舍五入对应到二进制中，就是 0 舍 1 入
5. 溢出判断

结论：因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3

#### 怎么解决这个问题？

```javascript
parseFloat((0.1 + 0.2).toFixed(10)); // 0.3

// 扩大倍数再缩小倍数
parseFloat((0.1 * 10 + 0.2 * 10) / 10);

// bignumber.js 源码地址：https://github.com/MikeMcl/bignumber.js
```

## css

### [盒子模型](https://segmentfault.com/a/1190000013069516)

盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。

- IE 模型元素宽度(border-box) width=content+padding
- 标准模型元素宽度(content-box) width=content

#### css 如何设置获取这两种模型的宽和高

`box-sizing: content-box | border-box`

#### javascript 如何设置/获取盒模型对应的宽和高

- `dom.style.width/height` 只能取到行内样式的宽和高，style 标签中和 link 外链的样式取不到。
- `dom.currentStyle.width/height` 取到的是最终渲染后的宽和高，只有 IE 支持此属性。
- `window.getComputedStyle(dom).width/height` 同（2）但是多浏览器支持，IE9 以上支持。
- `dom.getBoundingClientRect().width/height` 也是得到渲染后的宽和高，大多浏览器支持。IE9 以上支持，除此外还可以取到相对于视窗的上下左右的距离

#### 外边距重叠

当两个垂直外边距相遇时，他们将形成一个外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者(max)。注意：`只有普通文档流中块框的垂直外边距`才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并。

#### BFC

BFC(Block Formatting Context)：块级格式化上下文。

BFC 决定了`元素如何对其内容`进行定位，以及`与其他元素的关系和相互作用`。即，BFC 提供了一个环境，HTML 元素在这个环境中按照一定的规则进行布局，且不会影响到其他环境中的布局。

#### BFC 的原理（渲染规则）

- BFC 元素是一个`独立的容器`，外面的元素不会影响里面的元素，里面的元素也不会影响外面的元素
- BFC 元素垂直方向的边距会发生重叠，属于不同 BFC 外边距不会发生重叠
- BFC 的区域`不会与浮动元素的布局重叠`
- 计算 BFC 高度的时候，`浮动元素也会参与计算`(清除浮动)

#### 如何创建 BFC

- overflow 不为 visible;
- float 的值不为 none；
- position 的值不为 static 或 relative；
- display 属性为 inline-blocks,table,table-cell,table-caption,flex,inline-flex;

### [css 选择器](https://segmentfault.com/a/1190000013424772)

类别分：

- `简单选择器（Simple selectors）`：通过元素类型、class 或 id 匹配一个或多个元素。
- `属性选择器（Attribute selectors）`：通过 属性 / 属性值 匹配一个或多个元素。
- `伪类（Pseudo-classes）`：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是 DOM 树中一父节点的第一个子节点。
- `伪元素（Pseudo-elements）`:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。
- `组合器（Combinators）`：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择 divs 的直系子节点的段落，或者直接跟在 headings 后面的段落。
- `多用选择器（Multiple selectors）`：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个 CSS 规则下面， 以将一组声明应用于由这些选择器选择的所有元素。

#### 组合选择器

- A,B —— 满足二者之一即可
- 后代选择器 ——（空格键），后代，不一定是直接的
- 子选择器 —— > ，一个元素的直接子元素
- 相邻兄弟选择器 —— + ，一个元素的直接兄弟元素，只会向后选择
- 通用兄弟选择器 —— ~ ，其他元素的兄弟元素，只会向后选择

#### 属性选择器

尝试匹配精确的属性值

- [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。
- [attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。
- [attr~=val]：该选择器仅选择 attr 属性的值（以空格间隔出多个值）中有包含 val 值的所有元素，比如位于被空格分隔的多个类（class）中的一个类。

子串值~，也叫 伪正则选择器

- [attr|=val] : 选择 attr 属性的值以 val（包括 val）或 val-开头的元素（-用来处理语言编码）。
- [attr^=val] : 选择 attr 属性的值以 val 开头（包括 val）的元素。
- [attr$=val] : 选择 attr 属性的值以 val 结尾（包括 val）的元素。
- [attr*=val] : 选择 attr 属性的值中包含字符串 val 的元素。

#### 伪类（Pseudo-class）

以冒号(:)作为前缀的关键字

> 当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）

- `:active`
- `:checked`
- `:disabled`
- `:first-child`
- `:first-of-type`
- `:focus`
- `:hover`
- `:last-child`
- `:last-of-type`
- `:visited`

#### 伪元素

伪元素（Pseudo-element）跟伪类很像，它们都是关键字 —— 但这次伪元素前缀是两个冒号 (::)

> 同样是添加到选择器后面达到指定某个元素的某个部分。

- `::after`
- `::before`
- `::first-letter`
- `::first-line`
- `::selection`
- `::backdrop`

### [BFC](https://zhuanlan.zhihu.com/p/25321647)

见上方盒模型

### [position](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/%E5%AE%9A%E4%BD%8D)

- static
  没有定位，元素出现在正常的流中

- inherit
  规定应该从父元素继承 position 属性的值。

- relative
  相对定位——相对于其正常位置进行定位。左右 margin 为 auto 仍然有效，并且不会脱离文档流。

- absolute
  绝对定位——脱离正常文档流，绝对定位的关键是找对参照物，找不到就以浏览器窗口进行定位

  - 参照物和绝对定位元素必须是包含与被包含关系；
  - 该参照物必须具有定位属性；

- fixed
  固定定位——生成绝对定位的元素，相对于浏览器窗口进行定位。会脱离文档流。

- sticky
  粘性定位——相对定位 relative 和固定定位 fixed 的结合，主要用在对 scroll 事件的监听上，比如吸顶效果

  使用条件：

  - 父元素不能有 overflow:hidden 或者 overflow:auto 属性
  - 父元素的高度不能低于 sticky 元素的高度，也就是要包裹住 sticky 元素
  - sticky 元素仅在其父元素内生效
  - sticky 元素只能指定 top、bottom、left、right 4 个值中的一个，否则只会处于相对定位

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sticky</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        height: 100vh;
        width: 100%;
      }
      h1 {
        height: 160px;
        position: relative;
        background-color: lightblue;
      }
      .sticky-nav {
        position: sticky;
        top: 0;
        width: 100%;
        height: 38px;
        border: 1px solid darkorange;
        background-color: yellowgreen;
      }
      .scroll-container {
        width: 100%;
        height: 1600px;
        background-color: lightgrey;
      }
      .inner-box {
        width: 100%;
        height: 366px;
        background-color: deeppink;
      }
    </style>
  </head>
  <body>
    <h1>高200px，距顶部100px</h1>
    <div class="sticky-nav">这是一个tab切换栏，给sticky定位top=100px</div>
    <div class="scroll-container">
      <p class="inner-box">滚动区</p>
    </div>
  </body>
</html>
```

### [flex 布局](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox | http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html | https://www.runoob.com/w3cnote/flex-grammar.html)

Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。一维布局。

采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。

它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。

#### 容器的属性

- flex-direction: `row | row-reverse | column | column-reverse`
- flex-wrap: `nowrap | wrap | wrap-reverse`
- flex-flow: `<flex-direction> <flex-wrap>`
- justify-content: `flex-start | flex-end | center | space-between | space-around`
- align-items: `flex-start | flex-end | center | baseline | stretch`
- align-content: `flex-start | flex-end | center | space-between | space-around | stretch`

#### 项目的属性

- align-self: `auto | flex-start | flex-end | center | baseline | stretch`; 单个项目有与其他项目不一样的对齐方式
- order: `<integer>`; 定义项目的排列顺序。数值越小，排列越靠前，默认为 0。
- flex-grow: `<number>`; 项目的放大比例，默认为 0，即如果存在剩余空间，也不放大
- flex-shrink: `<number>`; 项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小
- flex-basis: `<length> | auto`; 项目占据的主轴空间
- flex: `none | auto | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]`; 简略值：auto (1 1 auto) 和 none (0 0 auto)

### [css 优先级](https://zhuanlan.zhihu.com/p/41604775)

#### 什么是权重

> 多个样式作用到同一个元素上，权重规则生效

- 权重决定了 css 规则怎样被浏览器解析直到生效。“css 权重关系到你的 css 规则是怎样显示的”。
- 当很多的样式被应用到某一个元素上时，权重是一个决定哪种样式生效，或者优先级的过程。
- 每个选择器都有自己的权重。你的每条 css 规则，都包含一个权重级别。这个级别是由不同的选择器加权计算的，通过权重，不同的样式最终会作用到你的网页中。
- 如果两个选择器同时作用到一个元素上，权重高者生效。

#### 权重记忆口诀

从 0 开始，一个`行内样式+1000`，一个 `id 选择器+100`，一个`属性选择器、class 或者伪类+10`，一个元素选择器，或者伪元素+1，通配符+0。

#### 总结

- 常用选择器权重优先级：!important > id > class > tag
- !important > 行内样式 > 内联样式 and 外联样式，内联样式和外联样式的优先级和加载顺序有关
- !important 可以提升样式优先级，但不建议使用。如果!important 被用于一个简写的样式属性，那么这条简写的样式属性所代表的子属性都会被应用上!important。 例如：background: blue !important;
- 如果两条样式都使用!important，则权重值高的优先级更高
- 在 css 样式表中，同一个 CSS 样式你写了两次，后面的会覆盖前面的
- 样式指向同一元素，权重规则生效，权重大的被应用
- 样式指向同一元素，权重规则生效，权重相同时，就近原则生效，后面定义的被应用
- 样式不指向同一元素时，权重规则失效，就近原则生效，离目标元素最近的样式被应用

### [css 样式隔离](https://juejin.cn/post/6844904034281734151#heading-9)

- css Modules
- css-in-js
- shadow DOM

Shadow DOM 真正意义上的实现了 dom 和 css 的隔离。

CSS in JS，意思就是使用 js 语言写 css，完全不需要些单独的 css 文件，所有的 css 代码全部放在组件内部，以实现 css 的模块化。
CSS in JS 其实是一种编写思想，目前已经有超过 40 多种方案的实现，最出名的是 styled-components。

```jsx
import React from 'react';
import styled from 'styled-components';

// 创建一个带样式的 h1 标签
const Title = styled.h1`
  font-size: 1.5em;
  text-align: center;
  color: palevioletred;
`;

// 创建一个带样式的 section 标签
const Wrapper = styled.section`
  padding: 4em;
  background: papayawhip;
`;

// 通过属性动态定义样式
const Button = styled.button`
  background: ${(props) => (props.primary ? 'palevioletred' : 'white')};
  color: ${(props) => (props.primary ? 'white' : 'palevioletred')};

  font-size: 1em;
  margin: 1em;
  padding: 0.25em 1em;
  border: 2px solid palevioletred;
  border-radius: 3px;
`;

// 样式复用
const TomatoButton = styled(Button)`
  color: tomato;
  border-color: tomato;
`;

<Wrapper>
  <Title>Hello World, this is my first styled component!</Title>
  <Button primary>Primary</Button>
</Wrapper>;
```

#### css 模块化

### [css 性能优化](https://blog.csdn.net/weixin_43883485/article/details/103504171)

- 合并 css 文件，如果页面加载 10 个 css 文件,每个文件 1k，那么也要比只加载一个 100k 的 css 文件慢。
- 减少 css 嵌套，最好不要嵌套三层以上。
- 不要在 ID 选择器前面进行嵌套，ID 本来就是唯一的而且权限值大，嵌套完全是浪费性能。
- 建立公共样式类，把相同样式提取出来作为公共类使用。
- 减少通配符\*或者类似[hidden="true"]这类选择器的使用，挨个查找所有...这性能能好吗？
- 巧妙运用 css 的继承机制，如果父节点定义了，子节点就无需定义。
- 拆分出公共 css 文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独 css 文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。
- 不用 css 表达式，表达式只是让你的代码显得更加酷炫，但是对性能的浪费可能是超乎你想象的。
- 少用 css reset，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择 normolize.css。
- cssSprite，合成所有 icon 图片，用宽高加上 background-position 的背景图方式显现 icon 图，这样很实用，减少了 http 请求。
- 善后工作，css 压缩(在线压缩工具 YUI Compressor)
- GZIP 压缩，是一种流行的文件压缩算法。

避免使用@import，外部的 css 文件中使用@import 会使得页面在加载时增加额外的延迟。

- @import 引入 css 会影响浏览器的并行下载。使用@import 引用的 css 文件只有在引用它的那个 css 文件被下载，解析之后，浏览器才会知道还有另外一个 css 需要下载，这时才去下载，然后下载后开始解析，构建 render tree 等一系列操作，这就导致浏览器无法并行下载。

- 多个@import 会导致下载顺序紊乱

#### 避免过分重排

##### 导致 reflow 发生的情况

- 改变窗口的大小
- 改变文字的大小
- 添加、删除样式表
- 内容的改变，输入框输入内容也会
- 伪类的激活
- 操作 class 属性
- 脚本操作 dom js 改变 css 类
- 计算 offsetWidth 和 offsetHeight
- 设置 style 属性
- 改变元素的内外边距

##### 常见重排元素

- 大小有关的 width,height,padding,margin,border-width,border,min-height
- 布局有关的 display,top,position,float,left,right,bottom
- 字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align
- 隐藏有关的 overflow,overflow-x,overflow-y

#### CSS 动画

- css 动画启用 GPU 加速，应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 完成。canvas2D，布局合成，css3 转换，css3d 变换，webGL，视频
- 2d 加速
- 3d 加速

#### 减少 reflow 对性能的影响的建议

- 不要一条条的修改 dom 的样式，预先定义好 class，然后修改 dom 的 classname
- 不要修改影响范围较大的 dom
- 为动画元素使用绝对定位
- 不要 table 布局，因为一个很小的改动会造成整个 table 重新布局
- 避免设置大量的 style 属性，通过设置 style 属性改变节点样式的话，每一次设置都会触发一次 reflow，所以最好使用 class 属性
- 如果 css 里面有计算表达式，每次都会重新计算一遍，触发一次 reflow

#### 文件压缩

使用构建工具 webpack，gulp/grunt，rollup，优化配置

#### 去除无用 CSS

虽然文件压缩能够降低文件大小，但 css 文件压缩通常只会去除无用的空格，这样就限制来 css 文件的压缩比例。如果压缩后的文件仍然超过来预期的大小，可以试着找到并删除代码中无用的 css。
一般情况下，会存在这两种无用的 CSS 代码：

- 不同元素或者其他情况下的重复代码
- 整个页面内没有生效的 CSS 代码

#### 有选择地使用选择器

css 选择器的匹配是从右向左进行的

- 保持简单，不要使用嵌套过多过于复杂的选择器
- 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。
- 不要使用类选择器和 ID 选择器修饰元素标签，如：h3#markdown-content，这一多此一举，还会降低效率
- 不要为了追求速度而放弃可读性和可维护性

> 为什么 css 选择器是从右向左匹配的？
> css 中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率，从右向左匹配就是为了达成这一目的的，通过这一策略能够使得 css 选择器在不匹配的时候效率更高。

#### 尽量减少使用昂贵的属性

box-shadow, border-radius, filter, 透明度, :nth-child 等

#### 硬件加速的好坏

- 仅仅依靠 GPU 还是不行的，许多动画还是需要 CPU 的介入，连接 cpu 和 GPU 的总带宽不是无限的，所以需要注意数据在 cpu 和 GPU 之间的传输，尽量避免造成通道的拥挤，要一直注意像素的传输。
- 一个重点是了解创建的合成层的数量，每一个层都对应来一个 GPU 纹理，太多的层会消耗很多内存。
- **chrome://flags/#composited-layer-borders**观察的地址。
- 每一个 dom 元素的合成层都会被标记一个额外的边框，这一就可以验证是否有了很多层
- 另一个重点是保持 GPU 和 CPU 之间传输量达到最小值，也就是说，层的更新数量最好是一个理想的常量，每次层更新的时候，一堆新的像素就可能需要传输给 GPU。
- 因为为了高性能，动画开始之后避免层的更新也是非常重要的，避免动画进行中其他层一直更新导致拥堵。
- 也就是使用这些 css 属性来实现动画：transformation, opacity, filter
- 使用性能工具检测优化的合理性，timeline 检测优化是否合理，还需要实现自动操作来做性能回归测试。
- 检测层数和层更新次数是非常有用的。

### [层叠上下文](https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/)

对于 CSS 世界中的元素而言，所谓的“冲突”指什么呢，其中，很重要的一个层面就是“层叠显示冲突”。

默认情况下，网页内容是没有偏移角的垂直视觉呈现，当内容发生层叠的时候，一定会有一个前后的层叠顺序产生，有点类似于真实世界中论资排辈的感觉。

CSS 中的层叠上下文和层叠顺序

层叠上下文，英文称作”stacking context”. 是 HTML 中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在 z 轴上就“高人一等”。

z 轴，指的是什么呢？表示的是用户与屏幕的这条看不见的垂直线

“层叠水平”英文称作”stacking level”，决定了同一个层叠上下文中元素在 z 轴上的显示顺序。

普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义，层叠水平所有的元素都存在。

层叠上下文和层叠水平是概念，而这里的层叠顺序是规则。

层叠顺序 (由高到低)

- 正 z-index
- z-index:auto 或 z-index: 0
- inline/inline-block 水平盒子
- float 浮动盒子
- block 块状水平盒子
- 负 z-index
- 层叠上下文

为什么内联元素的层叠顺序要比浮动元素和块状元素都高？

诸如 border/background 一般为装饰属性，而浮动和块状元素一般用作布局，而内联元素都是内容。网页中最重要的是什么？当然是内容了哈，对不对！
一定要让内容的层叠顺序相当高，当发生层叠是很好，重要的文字啊图片内容可以优先暴露在屏幕上。

#### 层叠领域的黄金准则

当元素发生层叠的时候，其覆盖关系遵循下面 2 个准则：

- 谁大谁上：当具有明显的层叠水平标示的时候，如识别的 z-indx 值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。
- 后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。

#### 层叠上下文的特性

层叠上下文元素有如下特性：

- 层叠上下文的层叠水平要比普通元素高（原因后面会说明）；
- 层叠上下文可以阻断元素的混合模式（见此文第二部分说明）；
- 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。
- 每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。
- 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。

#### 层叠上下文的创建

> 层叠上下文也基本上是有一些特定的 CSS 属性创建的

- 页面根元素天生具有层叠上下文，称之为“根层叠上下文”。页面根元素<html>元素
- z-index 值为数值的定位元素的传统层叠上下文。
- 其他 CSS3 属性。

#### 结束语

z-index 根本就没有出现的必要。知道了内联元素的层叠水平比块状元素高，于是，某条线你想覆盖上去的时候，需要设置 position:relative 吗？不需要，inline-block 化就可以。因为 IE6/IE7 position:relative 会创建层叠上下文，很烦的。

### [div 居中](https://juejin.cn/post/6844903821529841671)

flex 布局实现居中
justify-content / align-item

已知宽高，width + absolute + margin

```css
.a {
  width: 100px;
  height: 100px;
  background-color: blue;
  position: absolute;
  left: 50%;
  top: 50%;
  margin: -50px 0 0 -50px;
}
```

已知宽度，width + absolute + margin:auto

```css
.a {
  width: 100px;
  height: 100px;
  background-color: blue;
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
}
```

未知宽高，absolute + translate

```css
.a {
  background-color: blue;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

table-cell 布局实现

display：table-cell 会使元素表现的类似一个表格中的单元格 td，利用这个特性可以实现文字的垂直居中效果。

使用 table-cell 时最好不要与 float 以及 position: absolute 一起使用，设置了 table-cell 的元素对高度和宽度高度敏感，对 margin 值无反应，可以响应 padding 的设置，表现几乎类似一个 td 元素。

- 不要与 float：left， position : absolute， 一起使用
- 可以实现大小不固定元素的垂直居中
- margin 设置无效，响应 padding 设置
- 对高度和宽度高度敏感
- 不要对 display：table-cell 使用百分比设置宽度和高度

### [浮动](https://segmentfault.com/a/1190000012739764)

实现页面布局主要应用到两种方法，一种是 CSS 浮动，一种是 Flexbox（IE9 以上）

什么是浮动元素？

浮动元素同时处于常规流内和流外的元素。其中块级元素认为浮动元素不存在，而浮动元素会影响行内元素的布局，浮动元素会通过影响行内元素间接影响了包含块的布局。

- 常规流：页面上从左往右，从上往下排列的元素流，就是常规流
- 脱离常规流：绝对定位，fixed 定位的元素有自己固定的位置，脱离了常规流
- 包含块：一个元素离它最近的块级元素是它的包含块

#### 浮动元素的摆放会遵循如下的规则：

- 尽量靠上
- 尽量靠左
- 尽量一个挨着一个
- 不能超出包含块，除非元素比包含块更宽
- 不能超过所在行的最高点
- 不能超过它前面浮动元素的最高点
- 行内元素绕着浮动元素摆放：左浮动元素的右边和右浮动元素的左边会出浮动元素

#### 闭合浮动的方法

BFC：块级格式化上下文。它是一个独立的渲染区域，只有 Block-level box 参与，它规定了内部的块级元素如何布局，并且与这个区域外部毫不相干。

只要符合以下的条件就是 BFC:

- 根元素
- float 属性不为 none
- position 为 absolute 或 fixed
- display 为 inline-block, table-cell, table-caption, flex, inline-flex
- overflow 不为 visible

伪元素

`clear:both;` 意味着块级元素的左边和右边都不能有浮动元素。在包含块的末尾建立了一个内容为空的伪元素，并设置 clear:both，使这个元素位于所有的浮动元素之后，从而撑开了包含块的高。

```css
.clearfix::after {
  content: '';
  display: block;
  clear: both;
}
```

### [css3 新特性](https://segmentfault.com/a/1190000010780991)

#### 过渡 transition

`transition： CSS 属性，花费时间，效果曲线(默认 ease)，延迟时间(默认 0)`

`transition：width,.5s,ease,.2s`

- transition-property: width;
- transition-duration: 1s;
- transition-timing-function: linear;
- transition-delay: 2s;

#### 动画 animation

`animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）`

`animation-fill-mode : none | forwards | backwards | both;` 是否反向

- none：不改变默认行为。
- forwards ：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。
- backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。
- both：向前和向后填充模式都被应用

> [css3-loading](https://www.html5tricks.com/demo/css3-loading-cool-styles/index.html)

#### 形状转换 transform

2d 转换和 3d 转换

transform:适用于 2D 或 3D 转换的元素

transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)

- rotate()
- translate()
- scale()
- skew()
- ~X(),~Y(),~Z(),~3d()

#### 选择器

见上方 css 选择器

#### 阴影 box-shadow

`box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向(默认是从里往外，设置inset就是从外往里)`

#### 边框 border

border-image

```css
.border {
  padding: 15px;
  border: 15px solid transparent;
  border-image: url(border.png);
  border-image-slice: 30;
  border-image-repeat: round;
  border-image-outset: 0;
}
```

border-radius

#### 背景 background

- background-clip: `border-box|padding-box|content-box`;

指定背景绘制（显示）区域

- background-origin: `border-box|padding-box|content-box`;

指定 background-position 属性相对位置

- background-size: `contain|cover|auto 100%|<number> px`;

指定背景的大小

#### 倒影 -webkit-box-reflect

-webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片

```css
reflect-bottom-mask {
  -webkit-box-reflect: below 0 linear-gradient(transparent, white);
}
```

#### 文字

换行 word-break: normal|break-all|keep-all;

单行超出省略

```css
 {
  width: 200px;
  border: 1px solid #000000;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
```

多行超出省略号

```css
.text {
  overflow: hidden;
  border: 1px solid #ccc;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}
```

文字阴影

text-shadow:水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。

#### 颜色 rgba hsla

rgba（rgb 为颜色值，a 为透明度）

h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”

```css
* {
  color: hsla(112, 72%, 33%, 0.68);
}
```

#### 渐变 gradient

- liner-gradient 线性渐变
- ridical-gradient 径向渐变
- conic-gradient 圆锥渐变

#### 滤镜 Filter

`filter: grayscale()|sepia()|saturate()|hue-rotte()|invert()|opacity()|brightness()|contrast()|blur()|drop-shadow()`

#### 弹性布局 flex

见上方 flex，一维布局

#### 栅格布局 grid

二维布局 [Grid](http://www.jianshu.com/p/d183265a8dad)

#### 盒模型 box model

见上方

#### 媒体查询 media query

```css
@media screen and (max-width: 960px) {
  body {
    background-color: darkgoldenrod;
  }
}
@media screen and (max-width: 480px) {
  body {
    background-color: lightgreen;
  }
}
```

#### 混合模式

就像 photoshop 里面的混合模式

background-blend-mode

mix-blend-mode

### [双飞翼/圣杯布局](https://juejin.cn/post/6844903817104850952)

## html&浏览器

### [行内元素、块级元素](https://www.cnblogs.com/yc8930143/p/7237456.html)

行内元素

a, span, label, strong, em, br, img, input, select, textarea, cite,

块级元素

div, h1~h6, p, form, ul, li, ol, dl, address, hr, menu, table, fieldset

区别：

是否独占一行？默认宽度怎么确定？

- 块级元素会独占一行，垂直方向排列，其宽度自动填满其父元素宽度；
- 行内元素不会独占一行，相邻的行内元素会排列在同一行里，水平方向排列，直到一行排不下，才会换行，其宽度随元素的内容而变化。

能否设置 width/heihgt？

- 块级元素可以设置 width，height 属性【注意：块级元素即使设置了宽度，仍然是独占一行的】；
- 行内元素设置 width, height 无效(可以设置 line-height)，宽度只与内容有关。

能否设置 margin 和 padding？

- 块级元素可以设置 margin 和 padding；
- 行内元素的 margin 和 padding 水平方向有效，竖直方向无效，即上下无效。

能否任意嵌套？

- 块级元素可以包含行内元素和块级元素(p 标签中不能嵌套 div 标签)；
- 行内元素不能包含块级元素，行内元素只能容纳文本或者其他行内元素。

### [跨标签页通信](https://juejin.cn/post/6844903811232825357)

#### 同源页面

##### 广播模式

BroadcastChannel 接口代理了一个命名频道，可以让指定 origin 下的任意 browsing context 来订阅它。它允许同源的不同浏览器窗口，Tab 页，frame 或者 iframe 下的不同文档之间相互通信。通过触发一个 message 事件，消息可以广播到所有监听了该频道的 BroadcastChannel 对象。此特性在 Web Worker 中可用。

```javascript
// 创建一个标识为 gornin 的频道
const bc = new BroadcastChannel('gornin');

// 发送消息
bc.postMessage(mydata);

// 【各页面】通过onmessage来监听被广播的消息
bc.onmessage = function (e) {
  const { msg, from } = e.data;
  const text = '[receive]:' + msg + ' —— [from tab]:' + from;
  console.log('[BroadcastChannel] receive message:', text);
};
```

Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。

1. 注册 Service Worker
2. 对应的 Service Worker 脚本
3. 监听 Service Worker 发送来的消息
4. 同步消息调用 Service Worker 的 postMessage 方法

```javascript
/* 页面逻辑 */
// 注册service worker
navigator.serviceWorker.register('../util.sw.js').then(function () {
  console.log('Service Worker 注册成功');
});

// 监听message
navigator.serviceWorker.addEventListener('message', function (e) {
  const data = e.data;
  const text = '[receive] ' + data.msg + ' —— tab ' + data.from;
  console.log('[Service Worker] receive message:', text);
});

// 同步消息
navigator.serviceWorker.controller.postMessage(mydata);

/* ../util.sw.js Service Worker 逻辑 */
// Service Worker 本身并不自动具备“广播通信”的功能，需要我们添加些代码，将其改造成消息中转站
self.addEventListener('message', function (e) {
  console.log('service worker receive message', e.data);
  e.waitUntil(
    // 通过self.clients.matchAll()获取当前注册了该 Service Worker 的所有页面，通过调用每个client（即页面）的postMessage方法，向页面发送消息。
    self.clients.matchAll().then(function (clients) {
      if (!clients || clients.length === 0) {
        return;
      }
      clients.forEach(function (client) {
        client.postMessage(e.data);
      });
    })
  );
});
```

利用 StorageEvent，当 LocalStorage 变化时，会触发 storage 事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听 storage 事件即可收到通知。

```javascript
// 监听storage事件
window.addEventListener('storage', function (e) {
  if (e.key === 'ctc-msg') {
    const data = JSON.parse(e.newValue);
    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;
    console.log('[Storage I] receive message:', text);
  }
});

// 触发storage事件
mydata.st = +new Date();
window.localStorage.setItem('ctc-msg', JSON.stringify(mydata));
```

##### 共享存储+轮询模式

普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。

```javascript
// 在页面中启动一个 Shared Worker
// 构造函数的第二个参数是 Shared Worker 名称，也可以留空
const sharedWorker = new SharedWorker('../util.shared.js', 'ofo');

// 定时轮询，发送 get 指令的消息
setInterval(function () {
  sharedWorker.port.postMessage({ get: true });
}, 1000);

// 监听 get 消息的返回数据
sharedWorker.port.addEventListener(
  'message',
  (e) => {
    const { msg, from } = e.data;
    const text = '[receive]：' + msg + ' —— 【from tab】：' + from;
    console.log('[Shared Worker] receive message:', text);
  },
  false
);
sharedWorker.port.start();

// 发送消息
sharedWorker.port.postMessage(mydata);

/* ../util.shared.js: Shared Worker 代码 */
let data = null;
self.addEventListener('connect', function (e) {
  const port = e.ports[0];
  port.addEventListener('message', function (event) {
    // get 指令则返回存储的消息数据
    if (event.data.get) {
      data && port.postMessage(data);
    }
    // 非 get 指令则存储该消息数据
    else {
      data = event.data;
    }
  });
  port.start();
});
```

有些时候使用“共享存储”的形式时，不一定要搭配长轮询。
例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听 visibilitychange 这样的事件，来做一次信息同步即可。

window.open + window.opener
当我们使用 window.open 打开页面时，方法会返回一个被打开页面 window 的引用。而在未显式指定 noopener 时，被打开的页面可以通过 window.opener 获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。

```javascript
// 把window.open打开的页面的window对象收集起来
let childWins = [];
document.getElementById('btn').addEventListener('click', function () {
  const win = window.open('./some/sample');
  childWins.push(win);
});

// 当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面
// 过滤掉已经关闭的窗口
childWins = childWins.filter((w) => !w.closed);
if (childWins.length > 0) {
  mydata.fromOpenner = false;
  childWins.forEach((w) => w.postMessage(mydata));
}
if (window.opener && !window.opener.closed) {
  mydata.fromOpenner = true;
  window.opener.postMessage(mydata);
}

// 一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）
window.addEventListener('message', function (e) {
  const data = e.data;
  const text = '[receive] ' + data.msg + ' —— tab ' + data.from;
  console.log('[Cross-document Messaging] receive message:', text);
  // 避免消息回传
  if (window.opener && !window.opener.closed && data.fromOpenner) {
    window.opener.postMessage(data);
  }
  // 过滤掉已经关闭的窗口
  childWins = childWins.filter((w) => !w.closed);
  // 避免消息回传
  if (childWins && !data.fromOpenner) {
    childWins.forEach((w) => w.postMessage(data));
  }
});
```

通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端。

---

#### 非同源页面

要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定 origin 来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：http://sample.com/bridge.html），而这些 iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。

```javascript
/* 业务页面代码 */
// 在页面中监听 iframe 发来的消息
window.addEventListener('message', function (e) {
  // …… do something
});

// 当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息
window.frames[0].window.postMessage(mydata, '*');

/* iframe 内代码 */
// 使用 BroadcastChannel 为例
const bc = new BroadcastChannel('gornin');
// 收到来自页面的消息后，在 iframe 间进行广播
window.addEventListener('message', function (e) {
  bc.postMessage(e.data);
});

/* iframe 内代码 */
// 对于收到的（iframe）广播消息，通知给所属的业务页面
bc.onmessage = function (e) {
  window.parent.postMessage(e.data, '*');
};
```

#### 总结

对于同源页面，常见的方式包括：

- 广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent
- 共享存储模式：Shared Worker / IndexedDB / cookie
- 口口相传模式：window.open + window.opener
- 基于服务端：Websocket / Comet / SSE 等

而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。

此外 url 传参，hashChange 等也可以

### [history、hash 路由](https://blog.csdn.net/Charissa2017/article/details/104779412)

为什么要使用路由

现在的网络应用程序越来越多的使用 AJAX 异步请求完成页面的无缝刷新，导致浏览器的 URL 不会发生任何变化而完成了请求，从而破换了用户浏览体验。同时本次浏览的页面内容在用户下次使用 URL 访问时将无法重新呈现，使用路由可以很好地解决这个问题。

单页面应用利用了 JavaScript 动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面 web 应用。

路由需要实现三个功能：

- 当浏览器地址变化时，切换页面；
- 点击浏览器【后退】、【前进】按钮，网页内容跟随变化；
- 刷新浏览器，网页加载当前路由对应内容；

在单页面 web 网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的 hash 网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用 js 实现动态改变网页内容，有两种实现方式：

- hash 模式：监听浏览器地址 hash 值变化，执行相应的 js 切换网页；
- history 模式：利用 history API 实现 url 地址改变，网页内容改变；

二者区别最明显的就是 hash 会在浏览器地址后面增加#号，而 history 可以自定义地址。

hash 模式

使用 window.location.hash 属性及窗口的 onhashchange 事件，可以实现监听浏览器地址 hash 值变化，执行相应的 js 切换网页。下面具体介绍几个使用过程中必须理解的要点：

- hash 指的是地址中#号以及后面的字符，也称为散列值。hash 也称作锚点，本身是用来做页面跳转定位的。如 http://localhost/index.html#abc，这里的#abc 就是 hash；
- 散列值是不会随请求发送到服务器端的，所以改变 hash，不会重新加载页面；
- 监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置 hash 值；
- location.hash 值的变化会直接反应到浏览器地址栏；

触发 hashchange 事件的几种情况：

- 浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发 window.location.hash 值的变化，从而触发 onhashchange 事件；
- 当浏览器地址栏中 URL 包含哈希如 `http://www.baidu.com/#home`，这时按下输入，浏览器发送`http://www.baidu.com/`请求至服务器，请求完毕之后设置散列值为#home，进而触发 onhashchange 事件；
- 当只改变浏览器地址栏 URL 的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发 onhashchange 事件；
- html 中\<a>标签的属性 href 可以设置为页面的元素 ID 如 #top，当点击该链接时页面跳转至该 id 元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发 onhashchange 事件；

history 模式

- window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。
- History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。
- 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。
- 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。

History 对象主要有两个属性

- History.length：当前窗口访问过的网址数量（包括当前网页）
- History.state：History 堆栈最上层的状态值（详见下文）

History 对象用于在历史之中移动的方法

- History.back()：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。
- History.forward()：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。
- History.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为 0，相当于刷新当前页面。

- History.pushState(object||null, title||'', 同域 new_url)，该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化。

- History.replaceState(object, '', url)，该方法用来修改 History 对象的当前记录

popstate 事件

每当 history 对象出现变化时，就会触发 popstate 事件

- 仅仅调用 pushState()方法或 replaceState()方法 ，并不会触发该事件;
- 只有用户点击浏览器`倒退`按钮和`前进`按钮，或者使用 JavaScript 调用 History.back()、History.forward()、History.go()方法时才会触发。
- 另外，该事件`只针对同一个文档`，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。
- 页面第一次加载的时候，浏览器不会触发 popstate 事件。

```javascript
window.addEventListener('popstate', function (e) {
  // event 对象的 state 属性指向当前的 state 对象
  // e.state 相当于 history.state
  console.log('state: ' + JSON.stringify(e.state));
  console.log(history.state);
});
```

history 致命的`缺点`就是当改变页面地址后，强制刷新浏览器时，（如果后端没有做准备的话）会报错，因为刷新是拿当前地址去请求服务器的，如果服务器中没有相应的响应，会出现 404 页面。故，history 模式需要后端配合处理 404 的情况。

### [dom 树](https://blog.poetries.top/browser-working-principle/guide/part5/lesson22.html#javascript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-dom-%E7%94%9F%E6%88%90%E7%9A%84)

DOM 提供了对 HTML 文档结构化的表述，从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，即 DOM。

#### DOM 有三个层面的作用

- 从页面的视角来看，`DOM 是生成页面的基础数据结构`。
- 从 JavaScript 脚本视角来看，`DOM 提供给 JavaScript 脚本操作的接口`，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。
- 从安全视角来看，`DOM 是一道安全防护线`，一些不安全的内容在 DOM 解析阶段就被拒之门外了。

#### DOM tree 是如何构建的？

在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。

HTML 解析器并不是等整个文档加载完成之后再解析的，而是`网络线程`加载了多少数据，HTML 解析器便解析多少数据。

`网络线程`接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个`渲染进程`。

`渲染进程`准备好之后，`网络线程`和`渲染进程`之间会建立一个`共享数据的管道`，`网络线程`接收到数据后就往这个管道里面放，而`渲染进程`则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。

你可以把这个管道想象成一个“水管”，`网络线程`接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是`渲染进程`的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。

#### 字节流转换为 DOM 需要三个阶段

- 第一个阶段，`通过分词器将字节流转换为 Token`。

  - V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。
  - 解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。
    - Tag Token 又分 StartTag 和 EndTag

- 第二个和第三个阶段是同步进行的，需要`将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中`。
  - HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。
    - 如果压入到栈中的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
    - 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
    - 如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。

#### 预解析操作

当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

#### JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行

在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。

JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。

### [事件模型](https://javascript.ruanyifeng.com/dom/event.html)

#### 事件传播 [propagation] 三阶段

- 捕获阶段，由上层 window 对象传入底层目标节点的过程
- 目标阶段，在目标节点触发
- 冒泡阶段，由目标节点传回 window 对象

#### 绑定监听函数的三种方式

- html 标签中 on-属性，只会在冒泡阶段触发
  - html 与 js 分离
- 元素节点对象 node.onXxx，只会在冒泡阶段触发
  - 同一个事件只能定义一个监听函数，后定义会覆盖之前的定义
- addEventListener
  - 同一个事件可以添加多个监听函数
  - 能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数
  - 应用范围广泛，整个 JavaScript 统一的监听函数接口

#### EventTarget 接口，三个实例方法

- addEventListener：绑定事件的监听函数
  - 参数三，可选属性配置对象
  - capture：布尔值，表示该事件是否在捕获阶段触发监听函数。
  - once：布尔值，表示监听函数是否只触发一次，然后就自动移除。
  - passive：布尔值，表示`监听函数会不会调用事件的 preventDefault 方法`。
- removeEventListener：移除事件的监听函数
- dispatchEvent：触发事件

#### 事件代理 [delegation]

`把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件`

- 只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个节点上定义监听函数。
- 而且以后再添加子节点，监听函数依然有效。

#### Event 对象

- 实例属性
  - Event.bubbles，Event.eventPhase
  - Event.cancelable，Event.cancelBubble，event.defaultPrevented
  - Event.currentTarget，Event.target
  - Event.type
  - Event.timeStamp
  - Event.isTrusted
  - Event.detail
- 实例方法
  - Event.preventDefault()
  - Event.stopPropagation()
  - Event.stopImmediatePropagation()
  - Event.composedPath() 返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点

#### stopPropagation 与 stopImmediatePropagation

同：阻止事件的传播
异：对当前节点上的后续事件的处理方式不同

- 前者，不再往后续节点传播，当前节点上的后续事件还会执行
- 后者，不传播，当前节点后续事件也不会执行

#### target 与 currentTarget

- Event.currentTarget 属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。
- Event.target 属性返回原始触发事件的那个节点，即事件最初发生的节点。

事件传播过程中，不同节点的监听函数内部的 Event.target 与 Event.currentTarget 属性的值是不一样的，前者 target 总是不变的，后者 currentTarget 则是指向监听函数所在的那个节点对象。

#### 事件默认行为 preventDefault

- 点击链接后，浏览器默认会跳转到另一个页面，使用 preventDefault 后就不会跳转了；按一下空格键，页面向下滚动一段距离，使用 preventDefault 后也不会滚动了；
- 该方法生效的前提是，事件对象的 cancelable 属性为 true，如果为 false，调用该方法没有任何效果。

### [缓存策略](https://juejin.cn/post/6844903593275817998)

> https://www.yuque.com/go/doc/33914892

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

- 强制缓存

  - Expires http/1.0
  - Cache-Control http/1.1

- 协商缓存

  - Last-Modified / If-Modified-Since http/1.0
  - ETag / If-None-Match http/1.1

### [浏览器架构](https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3)

CPU 和 GPU 作为计算机中最重要的两个计算单元直接决定了计算性能。

- CPU (Central Processing Unit) 支持多核心

- GPU (Graphics Processing Unit) GPU 更擅长利用多核心同时处理单一的任务

还有比线程更小的存在就是协程，而协程是运行在线程中更小的单位。async/await 就是基于协程实现的。

#### IPC 跨进程通信

一个进程可以让操作系统开启另一个进程处理不同的任务。当两个进程需要通信时，可以时用 IPC(Inter Process Communication)。

#### 浏览器架构

浏览器可以被设计成单进程、多线程架构，或者利用 IPC 实现多进程、多线程架构。

`浏览器进程`作为 Chrome 中最核心的进程管理着 Chrome 中的其他进程，而 Renderer 则负责渲染不同的站点。

- `浏览器进程` Browser process
  - 负责地址栏、书签、前进和后退按钮，网络请求、文件按访问等，也负责其他进程的调度
- `渲染进程` Renderer process
  - 负责站点的渲染，js 代码运行，web worker 管理
- 插件进程 Plugin process
  - 负责为浏览器提供各种额外的插件功能，例如 flash
- GPU 进程 GPU process
  - 负责提供成像的功能

#### 浏览器进程

负责处理除了渲染外的大部分工作，`浏览器进程`包括几个线程：

- `UI 线程 UI thread` 负责绘制工具栏中的按钮、地址栏等
- `网络线程 Network thread` 负责从网络中获取数据
- `存储线程 Storage thread` 负责文件等功能

#### 多进程架构好处与问题

- 稳定性更好，tab 之间相互独立，一个 tab 卡顿或崩溃不会影响其他 tab，单进程由于共用线程，会造成互相影响，页面卡顿等现象
- 安全性更好，借助操作系统对进程安全的控制，浏览器可以`将页面放置在沙箱中`，站点的代码可以`运行在隔离的环境中`，保证核心进程的安全。

#### 面向服务的架构

Chrome 将架构从多进程模型转变成面向服务。

- 资源充足：当 Chrome 运行在拥有强大硬件的计算机上时，会将一个服务以多个进程的方式实现，提高稳定性
- 资源紧张：当计算机硬件资源紧张时，则可以将多个服务放在一个进程中节省资源

### [浏览器工作原理](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

- 浏览器内核，渲染引擎
- 解析构建 DOM 树——DOM 元素和属性节点构成的树结构
  - 自上而下解析器、自下而上解析器(移位归约解析器)
  - 解析流程：首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。
  - 词法分析，生成标记
  - 语法分析，分离无关字符
- 构建呈现树
- 布局
- 绘制
- 动态变化
- 事件循环

### [内存泄露](https://segmentfault.com/a/1190000020231307 | https://mp.weixin.qq.com/s/VhhQaZ6SCNJOtBAH2ffeUQ)

#### 内存生命周期

内存也是有生命周期的，不管什么程序语言，一般可以按顺序分为三个周期：

- 分配期，分配所需要的内存
- 使用期，使用分配到的内存（读、写）
- 释放期，不需要时将其释放和归还

内存分配 -> 内存使用 -> 内存释放。

内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。`无用的内存还在占用，得不到释放和归还。比较严重时，无用的内存会持续递增，从而导致整个系统卡顿，甚至崩溃。`

#### 内存泄漏的一些场景

- 意外的全局变量
- 被遗忘的计时器
- 被遗忘的闭包
- 被遗忘的事件监听器
- 被遗忘的 ES6 Set 成员，WeakSet 的成员是弱引用
- 被遗忘的 ES6 Map 键名，WeakMap 的键名是弱引用
- 被遗忘的订阅发布事件监听器
- 脱离 DOM 的引用，每个页面上的 DOM 都是占用内存的

#### 如何发现内存泄漏？

第一步：确定是否是内存泄漏问题

打开谷歌开发者工具，切换至 Performance 选项，勾选 Memory 选项。

运行按钮 -> 停止按钮

第二步：查找内存泄漏出现的位置

打开谷歌开发者工具，切换至 Memory 选项。页面上点击运行按钮，然后点击开发者工具左上角录制按钮，录制完成后继续点击录制，直到录制完三个为止。然后点击页面的停止按钮，再连续录制 3 次内存（不要清理之前的录制）。

记录 JavaScript 堆内存才是内存录制的主要目的，我们可以看到哪个堆占用的内存更高。

按照 Shallow Size 进行逆序排序。

## 性能

### [前端性能优化指标 RAIL](https://juejin.cn/post/6850037273312886797)

RAIL 是一个以用户为中心的性能模型，它把用户的体验拆分成几个关键点（例如，tap，scroll，load），并且帮你定义好了每一个的性能指标。

- Response
- Animation
- Idle
- Load

用户对性能延迟的感知时间点

- 16ms
- 100ms
- 1000ms

性能目标

- 聚焦用户
- 100ms 内响应用户的输入
- 10ms 内产生 1 帧，在滚动或者动画执行时
- 最大化主线程的空闲时间
- 5s 内让网页变得可交互

分析 RAIL 用的工具

- Chrome DevTools
- Lighthouse
- WebPageTest

#### Response: 事件处理最好在 50ms 内完成

目标

用户的输入到响应的时间不超过 100ms，给用户的感受是瞬间就完成了。

优化方案

- 事件处理函数在 50ms 内完成，考虑到 idle task 的情况，事件会排队，等待时间大概在 50ms。适用于 click，toggle，starting animations 等，不适用于 drag 和 scroll。
- 复杂的 js 计算尽可能放在后台，如 web worker，避免对用户输入造成阻塞
- 超过 50ms 的响应，一定要提供反馈，比如倒计时，进度百分比等。

> idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费 50ms 的时间，输入事件的响应则排在其后。

![idle task对input response的影响](https://user-gold-cdn.xitu.io/2020/7/13/173489db13875e5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### Animation: 在 10ms 内产生一帧

目标

- 产生每一帧的时间不要超过 10ms，为了保证浏览器 60 帧，每一帧的时间在 16ms 左右，但浏览器需要用 6ms 来渲染每一帧。
- 旨在视觉上的平滑。用户对帧率变化感知很敏感。

优化方案

- 在一些高压点上，比如动画，不要去挑战 cpu，尽可能地少做事，如：取 offset，设置 style 等操作。尽可能地保证 60 帧的体验。
- 在渲染性能上，针对不同的动画做一些特定优化

动画不只是 UI 的视觉效果，以下行为都属于

- 视觉动画，如渐隐渐显，tweens，loading 等
- 滚动，包含弹性滚动，松开手指后，滚动会持续一段距离
- 拖拽，缩放，经常伴随着用户行为

#### Idle: 最大化空闲时间

目标

最大化空闲时间，以增大 50ms 内响应用户输入的几率

优化方案

- 用空闲时间来完成一些延后的工作，如先加载页面可见的部分，然后利用空闲时间加载剩余部分，此处可以使用 requestIdleCallback API
- 在空闲时间内执行的任务尽量控制在 50ms 以内，如果更长的话，会影响 input handle 的 pending 时间
- 如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务

#### Load: 传输内容到页面可交互的时间不超过 5 秒

如果页面加载比较慢，用户的交点可能会离开。加载很快的页面，用户平均停留时间会变长，跳出率会更低，也就有更高的广告查看率

目标

- 优化加载速度，可以根据设备、网络等条件。目前，比较好的一个方式是，让你的页面在一个中配的 3G 网络手机上打开时间不超过 5 秒
- 对于第二次打开，尽量不超过 2 秒

优化方案

- 在手机设备上测试加载性能，选用中配的 3G 网络（400kb/s，400ms RTT），可以使用 WebPageTest 来测试
- 要注意的是，即使用户的网络是 4G，但因为丢包或者网络波动，可能会比预期的更慢
- 禁用渲染阻塞的资源，延后加载
- 可以采用 lazy load，code-splitting 等 其他优化手段，让第一次加载的资源更少

### [前端性能优化手段](https://alienzhou.com/projects/fe-performance-journey/#%E6%97%85%E9%80%94%E7%9A%84%E8%A1%8C%E7%A8%8B%E8%B7%AF%E7%BA%BF)

![前端性能优化手段](https://alienzhou.com/projects/fe-performance-journey/assets/img/overall.dcdd4140.svg)

1. 缓存

- 本地数据存储
  - cookie
  - localStorage/sessionStorage
  - indexedDB
- Memory Cache
- Cache API
- HTTP 缓存
  - 强缓存
  - 协商缓存
- Push Cache

2. 发送请求

- 避免不必要的重定向 301、302
- DNS 预解析
- 预先建立连接
- 使用 CDN

3. 服务端响应

- 使用流
- 业务接口内部聚合
- 避免代码问题

4. 页面解析与处理

- 资源位置顺序
- 合理使用 defer/async
- preload
- 关键渲染路径

5. 页面静态资源

- js
  - 减少不必要的请求
    - code split
    - 代码合并
  - 减少包体积大小
    - 代码压缩 uglify、gzip
    - tree shaking
    - 合理使用 polyfill
    - webpack 打包分析
  - 加快解析与执行
    - 初始加载、删除不必要的代码
    - 避免 long task
    - 考虑是否需要框架
    - 针对代码的编译优化
  - 缓存
    - 基于 hash 的文件名
    - 单独打包基础库
    - 打包导致的缓存失效
      - hash module id
      - runtime chunk split
      - 使用 records
- css
  - 使用关键 css
    - 内联
    - 骨架屏
  - 优化资源请求
    - 按需加载
    - 合并文件
    - 请求的优先级排序
    - 慎用@import
    - 谨慎对待 js 脚本位置
  - 减少包体大小
    - 压缩 uglify、gzip
    - 选择合适的 polyfill
  - 加快解析与渲染构建
    - 简化选择器
    - 避免使用昂贵的属性
    - 使用先进的布局方式
  - 利用缓存
    - webpack MiniCssExtractPlugin
- 图片
  - 优化请求
    - 雪碧图
    - 懒加载
    - base64
  - 减小图片大小
    - 合适的图片格式 webP，svg，video 代替 gif，pjpeg
    - 适当减低图片质量
    - 选择合适的大小、分辨率
    - 删除图片冗余信息
    - svg 压缩
  - 利用缓存，cdn 等
- 字体
  - 使用 font-display
  - 内联字体
  - 使用 css font loading API
  - FOFT
- 视频
  - 合适的视频格式
  - 视频压缩
  - 移除不必要的音轨信息
  - 使用流
  - 移除页面中不必要的视频

6. 运行时

- 注意强制同步布局
  - 避免代码出现在不合适的位置
  - 批量化操作
- 长列表优化
  - 实现 virtual list 机制
  - 原生 virtual scroller
- 避免 js 运行占用时间过长
  - 任务分解
  - 延迟执行
  - 并行计算
- 善用 composite 机制
- 滚动性能优化
- passive event listener

7. 预加载

- 预加载技术
  - resouce hints
    - prefetch
    - prerender
    - preload
  - 基于 js 实现的预加载
- 视频预加载技术
  - preload
  - link preload
  - 自定义 buffer
- 预加载策略
  - quicklink
  - guess.js

### [重排和重绘](https://juejin.cn/post/6844904083212468238)

#### 重排

当 DOM 的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。重排也叫回流，简单的说就是重新生成布局，重新排列元素。

下面情况会发生重排：

- 页面初始渲染，这是开销最大的一次重排
- 添加/删除可见的 DOM 元素
- 改变元素位置
- 改变元素尺寸，比如边距、填充、边框、宽度和高度等
- 改变元素内容，比如文字数量，图片大小等
- 改变元素字体大小
- 改变浏览器窗口尺寸，比如 resize 事件发生时
- 激活 CSS 伪类（例如：:hover）
- 设置 style 属性的值，因为通过设置 style 属性改变结点样式的话，每一次设置都会触发一次 reflow
- 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight 等，除此之外，当我们调用 getComputedStyle 方法，或者 IE 里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。

#### 重绘

当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。

重绘不一定导致重排，但重排一定会导致重绘。

#### 重排优化建议

减少重排范围
我们应该尽量以局部布局的形式组织 html 结构，尽可能小的影响重排的范围。

- 尽可能在低层级的 DOM 节点上，而不是像上述全局范围的示例代码一样，如果你要改变 p 的样式，class 就不要加在 div 上，通过父元素去影响子元素不好。

- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用 table 的场合，可以设置 table-layout:auto;或者是 table-layout:fixed 这样可以让 table 一行一行的渲染，这种做法也是为了限制 reflow 的影响范围。

减少重排次数

1. 样式集中改变

- 更改类名而不是修改样式
- 微小修改，统一在 cssText 变量中编辑

2. 分离读写操作

- 不要混着写

3. 将 DOM 离线

- 使用 display:none
- 通过 documentFragment 创建一个 dom 碎片
- 复制节点，在副本上工作，然后替换它

4. 使用 absolute 或 fixed 脱离文档流

5. 优化动画

- 把动画效果应用到 position 属性为 absolute 或 fixed 的元素上
- 启用 GPU 加速 GPU
  - transform
  - filter
  - transition

#### 如何在浏览器中查看页面渲染时间

performance -> record -> summary | Event Log

### [白屏](https://cloud.tencent.com/developer/article/1508941)

白屏性能优化

1. DNS 解析优化

针对 DNS Lookup 环节，我们可以针对性的进行 DNS 解析优化。

- DNS 缓存优化
- DNS 预加载策略
- 稳定可靠的 DNS 服务器

2. TCP 网络链路优化

针对网络链路的优化，好像除了花钱没有什么更好的方式！

3. 服务端处理优化

服务端的处理优化，是一个非常庞大的话题，会涉及到如 Redis 缓存、数据库存储优化或是系统内的各种中间件以及 Gzip 压缩等...

4. 浏览器下载、解析、渲染页面优化

根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：

- 尽可能的精简 HTML 的代码和结构
- 尽可能的优化 CSS 文件和结构
- 一定要合理的放置 JS 代码，尽量不要使用内联的 JS 代码

### [大量图片加载优化](https://zhuanlan.zhihu.com/p/33370207)

图片加载存在的问题和原因

问题一：启动页面时加载过多图片

在 Chrome 浏览器，对于同一个域名，最多支持 6 个请求的并发，其他的请求将会推入到队列中等待或者停滞不前，直到六个请求之一完成后，队列中新的请求才会发出。

问题二：部分图片体积过大

关注 Conent Download 阶段

解决方案：

```javascript
const inViewport = (el) => {
  const rect = el.getBoundingClientRect();

  return (
    rect.top > 0 &&
    rect.bottom < window.innerHeight &&
    rect.left > 0 &&
    rect.right < window.innerWidth
  );
};
```

优化策略：

- 首屏图片优先加载，等首屏图片加载完全后再去加载非首屏图片。
- 对大部分图片，特别是轮播广告中的图片进行按设备尺寸裁剪，减少图片体积，减少网络开销，加快下载速率。

### [描述下浏览器从输入网址到页面展现的整个过程](https://www.jianshu.com/p/d616d887953a)

1. 输入处理

当我们在地址栏中输入时，`UI 线程`会先判断我们输入的内容是`要搜索的内容`还是`要访问一个站点`，因为地址栏同时也是一个搜索框。

2. 访问开始

当我们按下回车开始访问时，`UI 线程`将借助`网络线程`访问站点资源。浏览器页签的标题上会出现加载中的图标，同时`网络线程`会根据适当的网络协议，例如 `DNS lookup` 和 `TLS` 为这次请求建立连接。

当服务器返回给浏览器重定向请求时，`网络线程`会通知 `UI 线程`需要重定向，然后会以新的地址做开始请求资源。

3. 处理响应数据

当`网络线程`收到来自服务器的数据时，会试图从数据中的前面的一些字节中得到数据的类型（Content-Type），以试图了解数据的格式。

当返回的数据类型是 HTML 时，会将数据传递给`渲染进程`做进一步的渲染工作。

但是如果数据类型是 zip 文件或者其他文件格式时，会将数据传递给下载管理器做进一步的文件预览或者下载工作。

在开始渲染之前，`网络线程`要先检查数据的安全性，这里也是浏览器保证安全的地方。

- 如果返回的数据来自一些恶意的站点，`网络线程`会显示警告的页面。
- 同时，Cross Origin Read Blocking(CORB)策略也会确保跨域的敏感数据不会被传递给`渲染进程`。

4. 渲染过程

当所有的检查结束后，`网络线程`确信浏览器可以访问站点时，`网络线程`通知 `UI 线程`数据已经准备好了。`UI 线程`会根据当前的站点找到一个`渲染进程`完成接下来的渲染工作。

UI 线程将请求地址传递给网络线程时，UI 线程就已经知道了要访问的站点。此时 UI 线程就可以开始查找或启动一个渲染进程，这个动作与让网络线程下载数据是同时的。如果网络线程按照预期获取到数据，则渲染进程就已经可以开始渲染了，这个动作减少了从网络线程开始请求数据到渲染进程可以开始渲染页面的时间。

5. 提交访问

数据和渲染进程都已经准备好了。浏览器进程会通过 IPC 向渲染进程提交这次访问，同时也会保证渲染进程可以通过网络线程继续获取数据。一旦浏览器进程收到来自渲染进程的确认完毕的消息，就意味着访问的过程结束了，文档渲染的过程就开始了。

这时，地址栏显示出表明安全的图标，同时显示出站点的信息。访问历史中也会加入当前的站点信息。为了能恢复访问历史信息，当页签或窗口被关闭时，访问历史的信息会被存储在硬盘中。

6. 加载完毕

当访问被提交给渲染进程，渲染进程会继续加载页面资源并且渲染页面。当渲染进程"结束"渲染工作，会给浏览器进程发送消息，这个消息会在页面中所有子页面（frame）结束加载后发出，也就是 onLoad 事件触发后发送。当收到"结束"消息后，UI 线程会隐藏页签标题上的加载状态图标，表明页面加载完毕。

但这里"结束"并不意味着所有的加载工作都结束了，因为可能还有 JavaScript 在加载额外的资源或者渲染新的视图。

7. 访问不同的站点

一次普通的访问到此就结束了。当我们输入另外一个地址时，浏览器进程会重复上面的过程。但是在开始新的访问前，会确认当前的站点是否关心 beforeunload 事件。

beforeunload 事件可以提醒用户是否要访问新的站点或者关闭页签，如果用户拒绝则新的访问或关闭会被阻止。

由于所有的包括渲染、运行 Javascript 的工作都发生在渲染进程中，浏览器进程需要在新的访问开始前与渲染进程确认当前的站点是否关心 unload。

#### 渲染进程负责页面的内容

渲染进程最重要的工作就是将 HTML、CSS 和 Javascript 代码转换成一个可以与用户产生交互的页面。

在一个渲染进程中，`主线程`负责解析，编译或运行代码等工作，当我们使用 Worker 时，Worker 线程会负责运行一部分代码。`合成线程`和`光栅线程`是也是运行在渲染进程中的，负责更高效和顺畅的渲染页面。

#### 渲染过程是昂贵的

在渲染过程中，任何一个步骤中产生的数据变化都会引起后续一系列的的变化。正常情况下渲染操作可以与屏幕刷新保持同步，但由于这些操作运行在主线程中，也就意味这些操作可能被正在运行的 Javascript 代码所阻塞。

为了不影响渲染操作，我们可以将 Javascript 操作优化成小块，然后使用 requestAnimationFrame()。当需要大量计算时，也可以使用 Worker 来避免阻塞主进程。

##### 解析过程

1. HTML parser 解析 html，构建 DOM tree

   - 额外资源的加载，为了提高效率，预加载扫描（Preload Scanner）与转换过程会同时运行着

   > 当预加载扫描在分析器分析 HTML 过程中发现了类似 img 或 link 这样的标签时，就会发送请求给浏览器进程的网络线程，而主线程会根据这些额外资源是否会阻塞转化过程而决定是否等待资源加载完毕。

   - js 阻塞解析工作，可能改变 dom
   - 不需要改变 dom，可为 script 标签添加 async 或 defer 属性，异步加载资源
   - 某些资源需要越快下载越好，使用预加载技术，\<link ref="preload">

2. 样式计算，style calculation

   需要样式来让页面变得更美观，主线程会解析样式（CSS）并决定每个 DOM 元素的样式

3. 布局 layout

   布局是为元素指定几何信息的过程。主线程遍历 DOM 结构中的元素及其样式，同时创建出带有坐标和元素尺寸信息的布局树（Layout tree）。

   使用 DOM 提供的 API 无法获取伪元素，因为伪元素存在与 layout tree，不存在 dom tree

4. 绘制记录

   主线程遍历布局树并创建绘制记录，绘制记录是一系列由绘制步骤组成的流程，例如先绘制背景，然后是文字，然后是形状。

5. 合成 Compositing

   浏览器已经知道了文档结构、每一个元素的样式、元素的几何信息、绘制的顺序。将这些信息转化成屏幕上像素的过程叫做光栅化，光栅化是图形学的范畴。

   合成是一种将页面拆分成多层的技术，合成线程可以将各个层在不同线程中光栅化，再组合成一个页面。当滚动时，如果层已经被光栅化，则会使用已经存在的层合成新的帧，动画则可以通过移动层来实现。

6. 层（Layer）

   为了决定层包含哪些元素，主线程需要遍历布局树以找到需要生成的部分。对开发者来说，当某一部分需要用独立的层渲染，我们可以使用 css 属性 will-change 让浏览器创建层

   分层是为了优化浏览器性能，但是过多的层反而影响性能。

7. 合成线程与栅格线程

   当布局树和绘制顺序确定以后，主线程会将这些信息提交给合成线程。

   合成线程会光栅化各个层。一个层包含的内容可能是一个完整的页面，也可能是页面的部分，所以合成线程将层拆分成许多块，并将它们发送给栅格线程。合成线程可以决定栅格线程光栅块的优先级。

   栅格线程光栅化这些块并将它们存储在 GPU 缓存中。

   当块被光栅化后，合成线程会使用 draw quads 收集这些信息并创建合成帧（Compositor frame）。

   Draw quads，存储在缓存中，包含类似块位置这样的信息，用于描述如何使用块合成页面。

   合成的好处在于其独立于主线程。合成线程不需要等待样式计算和 Javascript 代码的运行。这也是为什么合成更适合优化交互性能，但如果布局或者绘制需要重新计算则主线程是必须要参与的。

8. 合成帧

   用于存储表现页面一帧中包含哪些 Draw quads 的集合。

   然后一个合成帧被提交给浏览器进程。这时如果浏览器 UI 有变化，或者插件的 UI 有变化时，另一个合成帧就会被创建出来。所以每当有交互发生时，合成线程就会创建更多的合成帧然后通过 GPU 将新的部分渲染出来。

#### 合成线程对事件的处理

合成线程可以通过合成技术合成不同的光栅层优化性能，如果页面并不监听任何事件，合成线程可以完全独立于主线程生成新的合成帧。

如果页面监听了事件呢？

由于运行 Javascript 是主线程的工作，当页面被合成线程合成过，`合成线程会标记那些有事件监听的区域`。有了这些信息，`当事件发生在响应的区域时，合成线程就会将事件发送给主线程处理`。如果在非事件监听区域，则渲染进程直接创建新的帧而不关心主线程。

在 web 开发中常见的方式就是事件代理。利用事件冒泡，我们可以在目标元素的上层元素中监听事件。通过这种写法，可以更高效的监听事件。但如果从浏览器的角度看，此时整个页面会被标记成“慢滚动”区域。(Non-fast Scrollable region)

这意味着虽然页面中的某些部分并不需要事件监听，但合成线程依然要在每次交互发生后等待主线程处理事件，合成线程的优化效果不复存在。

为了解决这个问题，我们可在事件代理时传入 passive: true（IE 不支持）参数，此举防止调用事件监听器，因此在用户滚动时无法阻止页面呈现。

默认值 `passive: false` ，事件监听器在尝试处理滚动时可能会阻止浏览器的主线程，从而导致滚动处理期间性能可能大大降低。

[使用 passive 改善滚屏性能](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E7%9A%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD)

### [动画性能](https://www.jianshu.com/p/d24a891d4de6)

- 精简 DOM，合理布局
- 使用 transform 代替 left、top 减少使用引起页面重排的属性
- 开启硬件加速
- 尽量避免浏览器创建不必要的图形层
- 尽量减少 js 动画，如需要，使用对性能友好的 requestAnimationFrame
- 使用 chrome performance 工具调试动画性能

![帧绘制流程](https://segmentfault.com/img/bV7TBl?w=700&h=111)

依靠 js、css3 animation、css3 transition、web animation API 实现视觉变化的效果；

样式计算，计算出每个元素的最终样式；

布局，计算它要占据的空间大小及其在屏幕的位置；

绘制，是填充像素的过程；绘制一般是在多个表面（通常称为层）上完成的。

合成，由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。

提高网页性能，就是要降低"重排"和"重绘"的频率和成本，尽量少触发重新渲染。

![三种常见的渲染流程](https://segmentfault.com/img/bV7TKK?w=580&h=381)

分别是 重排、重绘、合成，重排重绘可以避免

#### 层 layer

在 Chrome 中实际上有几种不同类型的层：

- 掌管 DOM 子树的渲染层（RenderLayer）
- 掌管渲染层子树的图形层（GraphicsLayer）
- 某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer。

什么渲染层会提升为合成层？

- 进行 3D 或者透视变换的 CSS 属性
- 使用硬件加速视频解码的<video>元素
- 具有 3D（WebGL）上下文或者硬件加速的 2D 上下文的\<canvas>元素
- 具有有 CSS opacity 透明度动画或者使用动画式 Webkit transition 变换的元素
- 具有硬件加速的 CSS Filter 的元素
- 子元素中存在具有组合层的元素的元素（换句话说，就是存在具有自己的层的子元素的元素）
- 同级元素中有 z-index 比其小的元素，而且该 z-index 比较小的元素具有组合层（换句话说就是在组合层之上进行渲染的元素）
- 组合型插件（即 Flash）

提升为合成层有以下好处

- 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
- 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
- 对于 transform 和 opacity 效果，不会触发 layout 和 paint

### [渲染合成层](https://segmentfault.com/a/1190000014520786)

渲染大概可以划分成以下几个步骤：

- 解析 html 建立 dom 树
- 解析 css 构建 render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 render 树）
- 布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算
- 绘制 render 树（paint），绘制页面像素信息
- 浏览器会将各层的信息发送给 GPU（GPU 进程：最多一个，用于 3D 绘制等），GPU 会将各层合成（composite），显示在屏幕上。

### [Chrome Devtool Performance 使用指南](https://zhuanlan.zhihu.com/p/29879682)

## 工程化

### [模块化机制](https://segmentfault.com/a/1190000017466120)

### [uglify 原理](https://www.h5w3.com/19480.html)

### [babel 原理](https://my.oschina.net/u/4088983/blog/4545928)

### [webpack 工作流程](https://developer.aliyun.com/article/61047)

### [webpack 插件机制](https://juejin.cn/post/6844903789804126222)

### [webpack loader 机制](https://github.com/youngwind/blog/issues/101)

### [tree shaking](https://juejin.cn/post/6844903544756109319)

### [前端微服务](https://tech.antfin.com/community/articles/536)
