# 计算机基础

## 操作系统

### [进程和线程](https://juejin.cn/post/6844903801321685000)

进程 = 线程+内存+文件/网络句柄

线程 = 栈+PC+TLS

1. 进程是资源分配的最小单位，线程是程序执行调度的最小单位。
2. 进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了.
3. 一个程序至少有一个进程，一个进程至少有一个线程.
4. 一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行.

线程才是我们操作系统所真正去运行的，而进程则是像容器一样，他把需要的一些东西放在一起，而把不需要的东西做了一层隔离

缓冲区溢出：一个漏洞，可以被黑客利用执行脚本

PC，Program Counter 程序计数器，就是指向当前的指令，而这个指令是放在内存中。 每个线程都有一串自己的指针，去指向自己当前所在内存的指针。

TLS，thread local storage，线程本地存储

### [进程通信](https://www.jianshu.com/p/c1015f5ffa74)

Inter Process Communication

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到`内核缓冲区`，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，Inter Process Communication）

进程间通信的 7 种方式

- 管道/匿名管道(pipe)
- 有名管道(FIFO)
- 信号(Signal)
- 消息队列(Message Queue)
- 共享内存(share memory)
- 信号量(semaphore)
- 套接字(socket)

### [进程调度策略](https://blog.csdn.net/qq_35642036/article/details/82809812)

- 先来先服务调度算法
- 短作业(进程)优先调度算法
  对短作业或短进程优先调度的算法
- 高优先权优先调度算法
  为了照顾紧迫型作业，使之在进入系统后便获得优先处理
- 高响应比优先调度算法
- 时间片轮转法
- 多级反馈队列调度算法

### [死锁](https://www.jianshu.com/p/44125bb12ebf)

死锁

当线程 A 持有独占锁 a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。

造成死锁必须达成的 4 个条件（原因）：

- 互斥条件：一个资源每次只能被一个线程使用。
- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。
- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

如何避免？

在并发程序中，避免了逻辑中出现数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。

### [IO 多路复用](https://imageslr.github.io/2020/02/27/select-poll-epoll.html)

阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用多线程来处理多个文件描述符。

多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在一个线程里轮询多个文件描述符是否就绪。

但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查一个文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。

因此引入了 I/O 多路复用，可以通过一次系统调用，检查多个文件描述符的状态。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。

I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。

进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回。使用非阻塞 I/O 检查每个描述符的就绪状态。

如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞。

I/O 多路复用引入了一些额外的操作和开销，性能更差。但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的。这部分内容可以查看最下文 Redis 的线程模型。

## 网络

### [七层网络模型](https://zhuanlan.zhihu.com/p/32059190)

OSI 七层网络模型

- 应用层——为应用程序提供网络服务
- 表示层——数据格式化，加解密
- 会话层——建立、维护、管理会话
- 传输层——建立、维护、管理端到端连接
- 网络层——IP 寻址和路由选择
- 数据链路层——控制网络层与物理层之间通信
- 物理层——比特流传输，传输 byte 流，物理连接

TCP/IP 四层模型

- 应用层
- 传输层
- 网络层
- 数据链路层

![数据链路层数据包（以太网数据包）格式](https://pic2.zhimg.com/80/v2-3c8ab7e3f330238821adedea31b9c321_1440w.jpg)

![数据包在传送时的封装和解封装](https://pic3.zhimg.com/80/v2-80430dbb37a1e42315a77e30448b34b2_1440w.jpg)

### [http](https://coolshell.cn/articles/19840.html)

HTTP (Hypertext transfer protocol) 超文本传输协议

1991 年发布了 HTTP 0.9 版，在 1996 年发布 1.0 版，1997 年是 1.1 版，1.1 版也是到今天为止传输最广泛的版本

2015 年发布了 2.0 版，其极大的优化了 HTTP/1.1 的性能和安全性，而 2018 年发布的 3.0 版，继续优化 HTTP/2，激进地使用 UDP 取代 TCP 协议

HTTP/1.0

- 在请求中加入了 HTTP 版本号，如：GET /coolshell/index.html HTTP/1.0
- HTTP 开始有 header 了，不管是 request 还是 response 都有 header 了。
- 增加了 HTTP Status Code 标识相关的状态码。
- 还有 Content-Type 可以传输其它的文件了。

- 一个协议有没有版本管理，是一个工程化的象征。
- header 是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。
- Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。

问题

HTTP1.0 性能上有一个很大的问题，那就是每请求一个资源都要新建一个 TCP 链接，而且是串行请求，所以，就算网络变快了，打开网页的速度也还是很慢。所以，HTTP 1.0 应该是一个必需要淘汰的协议了。

HTTP/1.1

- HTTP/1.1 主要解决了 HTTP 1.0 的网络性能的问题
- 可以设置 keepalive 来让 HTTP 重用 TCP 链接，重用 TCP 链接可以省了每次请求都要在广域网上进行的 TCP 的三次握手的巨大开销。这是所谓的“HTTP 长链接” 或是 “请求响应式的 HTTP 持久链接”。英文叫 HTTP Persistent connection.
- 然后支持 pipeline 网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的 POST 方法或是有依赖的请求是不能被 pipeline 化的）
- 支持 Chunked Responses ，也就是说，在 Response 的时候，不必说明 Content-Length 这样，客户端就不能断连接，直到收到服务端的 EOF 标识。这种技术又叫 “服务端 Push 模型”，或是 “服务端 Push 式的 HTTP 持久链接”
- 还增加了 cache control 机制。
- 协议头注增加了 Language, Encoding, Type 等等头，让客户端可以跟服务器端进行更多的协商。
- 还正式加入了一个很重要的头—— HOST 这样的话，服务器就知道你要请求哪个网站了。因为可以有多个域名解析到同一个 IP 上，要区分用户是请求的哪个域名，就需要在 HTTP 的协议中加入域名的信息，而不是被 DNS 转换过的 IP 信息。
- 正式加入了 OPTIONS 方法，其主要用于 CORS – Cross Origin Resource Sharing 应用。

HTTP/1.1 应该分成两个时代，一个是 2014 年前，一个是 2014 年后，因为 2014 年 HTTP/1.1 有了一组 RFC（7230 /7231/7232/7233/7234/7235），这组 RFC 又叫“HTTP/2 预览版”。

其中影响 HTTP 发展的是两个大的需求：

- 一个需要是加大了 HTTP 的安全性，这样就可以让 HTTP 应用得广泛，比如，使用 TLS 协议。
- 另一个是让 HTTP 可以支持更多的应用，在 HTTP/1.1 下，HTTP 已经支持四种网络协议：
  - 传统的短链接。
  - 可重用 TCP 的的长链接模型。
  - 服务端 push 的模型。
  - WebSocket 模型。

### [https](https://zhuanlan.zhihu.com/p/26682342)

- 数据加密 传输内容进行混淆
- 身份验证 通信双方验证对方的身份真实性
- 数据完整性保护 检测传输的内容是否被篡改或伪造

HTTPS 采用共享密钥加密和公开密钥加密混合的加密方式，在交换密钥对环节使用公开密钥加密方式（防止被监听泄漏密钥）加密共享的密钥，在随后的通信过程中使用共享密钥的方式使用共享的密钥进行加解密。

数字证书

数字证书认证机构（Certificate Authority CA）是客户端和服务器双方都可信赖的第三方机构。

数字签名是只有信息发送者才能产生的别人无法伪造的一段文本，这段文本是对信息发送者发送信息真实性的一个有效证明，具有不可抵赖性。

### [http2.0](https://juejin.cn/post/6844903984524705800)

- 二进制分帧协议
- 多路复用
- 头部压缩
- 服务端推送
- 流控

http2.0 之所以能够突破 http1.X 标准的性能限制，改进传输性能，实现低延迟和高吞吐量，就是因为其新增了二进制分帧层。

在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。

http2.0 中的多路复用优化了这一性能。多路复用允许同时通过单一的 http/2 连接发起多重的请求-响应消息。有了新的分帧机制后，http/2 不再依赖多个 TCP 连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。

http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2 连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。

http1.x 的头带有大量信息，而且每次都要重复发送。http/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自缓存一份头部字段表，既避免了重复 header 的传输，又减小了需要传输的大小。

如果首部发生了变化，则只需将变化的部分加入到 header 帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。

http/2 的 HPACK 算法使用一份索引表来定义常用的 http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。

把 http 消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方-1 表示最低优先级。
服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。

服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤。

那么肯定要问 HTTP2.0 虽然性能已经不错了，还有什么不足吗？

- 建立连接时间长(本质上是 TCP 的问题，三次握手四次挥手)
- 队头阻塞问题，拥塞控制
- 移动互联网领域表现不佳(弱网环境)

### [http3.0](https://blog.csdn.net/wolfGuiDao/article/details/108729560)

我们单纯地看看 TCP 协议的不足和 UDP 的一些优点：

- 基于 TCP 开发的设备和协议非常多，兼容困难
- TCP 协议栈是 Linux 内部的重要部分，修改和升级成本很大
- UDP 本身是无连接的、没有建链和拆链成本
- UDP 的数据包无队头阻塞问题
- UDP 改造成本小

谷歌决定在 UDP 基础上改造一个具备 TCP 协议优点的新协议，这个新协议就是 QUIC 协议，Quick UDP Internet Connections

---

QUIC 协议存在的意义在于解决 TCP 协议的一些无法解决的痛点：

- 多次握手：TCP 协议需要三次握手建立连接，而如果需要 TLS 证书的交换，那么则需要更多次的握手才能建立可靠连接，这在如今长肥网络的趋势下是一个巨大的痛点
- 队头阻塞：TCP 协议下，如果出现丢包，则一条连接将一直被阻塞等待该包的重传，即使后来的数据包可以被缓存，但也无法被递交给应用层去处理。
- 无法判断一个 ACK 是重传包的 ACK 还是原本包的 ACK：比如 一个包 seq=1, 超时重传的包同样是 seq=1，这样在收到一个 ack=1 之后，我们无法判断这个 ack 是对之前的包的 ack 还是对重传包的 ack，这会导致我们对 RTT 的估计出现误差，无法提供更准确的拥塞控制
- 无法进行连接迁移：一条连接由一个四元组标识，在当今移动互联网的时代，如果一台手机从一个 wifi 环境切换到另一个 wifi 环境，ip 发生变化，那么连接必须重新建立，inflight 的包全部丢失。

现在我们给出一个 QUIC 协议的 Overview

- 更好的连接建立方式
- 更好的拥塞控制
- 没有队头阻塞的多路复用
- 前向纠错
- 连接迁移

### [websocket](https://blog.csdn.net/LL845876425/article/details/106393358)

为什么会出现？

HTTP 协议有一个的缺陷为：通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。

一个方案是使用轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。WebSocket 就是这样发明的。

Webscoket 是 Web 浏览器和服务器之间的一种全双工通信协议，一旦 Web 客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。通信过程中，可互相发送 JSON、XML、HTML 或图片等任意格式的数据。

WS（WebSocket）与 HTTP 协议相比，

相同点主要有：

- 都是基于 TCP 的应用层协议；
- 都使用 Request/Response 模型进行连接的建立；
- 在连接的建立过程中对错误的处理方式相同，在这个阶段 WS 可能返回和 HTTP 相同的返回码；
- 都可以在网络中传输数据。

不同之处在于：

- WS 使用 HTTP 来建立连接，但是定义了一系列新的 header 域，这些域在 HTTP 中并不会使用；
- WS 的连接不能通过中间人来转发，它必须是一个直接连接；
- WS 连接建立之后，通信双方都可以在任何时刻向另一方发送数据；全双工？
- WS 连接建立之后，数据的传输使用帧来传递，不再需要 Request 消息；
- WS 的数据帧有序。

### [tcp](https://coolshell.cn/articles/11564.html)

> https://zhuanlan.zhihu.com/p/47861654

1. 面向连接
2. 可靠传输
3. 面向字节流
4. 提供拥塞控制
5. 仅支持单播传输
6. 提供全双工通信

|          | TCP                                         | UDP                                    |
| -------- | ------------------------------------------- | -------------------------------------- |
| 是否连接 | 无连接                                      | 面向连接                               |
| 是否可靠 | 不可靠传输，不使用流量控制和拥塞控制        | 可靠传输，使用流量控制和拥塞控制       |
| 连接个数 | 支持一对一，一对多，多对一和多对多交互通信  | 只能是一对一通信                       |
| 传输方式 | 面向报文                                    | 面向字节流                             |
| 首部开销 | 首部开销小，仅 8 字节                       | 首部最小 20 字节，最大 60 字节         |
| 使用场景 | 适用于实时应用（IP 电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

### [udp](https://zhuanlan.zhihu.com/p/337678680)

1. 面向无连接
2. 不可靠传输，丢包不重发
3. 面向报文
4. 不提供复杂的控制机制，不保证顺序，不控制流量
5. 单播、多播、广播皆可
6. 资源开销小，传输数据报文时很高效，适合传输音视频
